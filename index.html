<!-- Apple-Style Ski Dining UI Generated by Cursor -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SNOGRUB - Discover the Best Eats in North American Ski Resorts</title>
    
    <!-- SEO Meta Tags -->
    <meta name="description" content="Discover the best restaurants, bars, and cafés at ski resorts across North America. Find dining options, read reviews, and plan your ski resort dining adventure.">
    <meta name="keywords" content="ski resorts, restaurants, dining, après-ski, ski resort dining, mountain restaurants, ski food">
    <meta name="author" content="SNOGRUB">
    <meta property="og:title" content="SNOGRUB - Discover the Best Eats in North American Ski Resorts">
    <meta property="og:description" content="Find the best restaurants, bars, and cafés at ski resorts across North America.">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://snogrub.com">
    <meta property="og:image" content="https://images.unsplash.com/photo-1506905925346-21bda4d32df4?ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D&auto=format&fit=crop&w=1200&q=80">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="SNOGRUB - Discover the Best Eats in North American Ski Resorts">
    <meta name="twitter:description" content="Find the best restaurants, bars, and cafés at ski resorts across North America.">
    <meta name="twitter:image" content="https://images.unsplash.com/photo-1506905925346-21bda4d32df4?ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D&auto=format&fit=crop&w=1200&q=80">
    <link rel="canonical" href="https://snogrub.com">
    
    <!-- Structured Data (JSON-LD) for SEO -->
    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "WebSite",
        "name": "SNOGRUB",
        "url": "https://snogrub.com",
        "description": "Discover the best restaurants, bars, and cafés at ski resorts across North America. Find dining options, read reviews, and plan your ski resort dining adventure.",
        "potentialAction": {
            "@type": "SearchAction",
            "target": {
                "@type": "EntryPoint",
                "urlTemplate": "https://snogrub.com/search-results.html?q={search_term_string}"
            },
            "query-input": "required name=search_term_string"
        }
    }
    </script>
    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "Organization",
        "name": "SNOGRUB",
        "url": "https://snogrub.com",
        "logo": "https://snogrub.com/logo.png",
        "description": "Your guide to the best dining at ski resorts across North America",
        "sameAs": [
            "https://www.facebook.com/skieats",
            "https://www.twitter.com/skieats",
            "https://www.instagram.com/skieats"
        ]
    }
    </script>
    
    <!-- Analytics Placeholder -->
    <!-- Google Analytics or other analytics can be added here -->
    <!-- <script async src="https://www.googletagmanager.com/gtag/js?id=GA_MEASUREMENT_ID"></script> -->
    
    <!-- TailwindCSS via CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Inter font (San Francisco-like) -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    
    <style>
        :root {
            --accent-blue: #0071e3; /* Apple blue - cool and winter-appropriate */
            --accent-light: #5ac8fa; /* Lighter blue for winter theme */
            --text-primary: #1d1d1f;
            --text-secondary: #86868b;
        }
        
        /* Apple-style typography and smoothing */
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }
        
        /* Frosted glass effect for navigation - Apple's signature translucent nav */
        .frosted-glass {
            background: rgba(0, 113, 227, 0.9); /* Blue background */
            backdrop-filter: saturate(180%) blur(20px);
            -webkit-backdrop-filter: saturate(180%) blur(20px);
        }
        
        /* Smooth transitions for all interactive elements */
        * {
            transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        @keyframes pulse {
            0%, 100% {
                transform: scale(1);
                opacity: 1;
            }
            50% {
                transform: scale(1.1);
                opacity: 0.9;
            }
        }
        
        /* Loading Spinner */
        .loading-spinner {
            border: 3px solid rgba(0, 113, 227, 0.1);
            border-top: 3px solid var(--accent-blue);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(4px);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }
        
        .loading-overlay.active {
            opacity: 1;
            pointer-events: all;
        }
        
        .skeleton {
            background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);
            background-size: 200% 100%;
            animation: loading 1.5s ease-in-out infinite;
            border-radius: 8px;
        }
        
        @keyframes loading {
            0% { background-position: 200% 0; }
            100% { background-position: -200% 0; }
        }
        
        /* Skeleton Card Styles */
        .skeleton-card {
            background: white;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            overflow: hidden;
        }
        
        .skeleton-image {
            width: 100%;
            aspect-ratio: 16/9;
            background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);
            background-size: 200% 100%;
            animation: loading 1.5s ease-in-out infinite;
        }
        
        .skeleton-text {
            height: 16px;
            margin-bottom: 8px;
            border-radius: 4px;
        }
        
        .skeleton-text.short {
            width: 60%;
        }
        
        .skeleton-text.medium {
            width: 80%;
        }
        
        .skeleton-text.long {
            width: 100%;
        }
        
        .skeleton-button {
            height: 36px;
            width: 120px;
            border-radius: 18px;
        }
        
        /* Winter gradient - subtle icy blue to white */
        .winter-gradient {
            background: linear-gradient(to bottom, #f0f8ff 0%, #ffffff 100%);
        }
        
        /* Hero background with parallax effect */
        .hero-background {
            position: absolute;
            inset: 0;
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            opacity: 0.4;
            z-index: 0;
            transform: translateZ(0);
            will-change: transform;
        }
        
        .hero-background-overlay {
            position: absolute;
            inset: 0;
            background: linear-gradient(to bottom, rgba(15, 23, 42, 0.6) 0%, rgba(15, 23, 42, 0.3) 50%, rgba(15, 23, 42, 0.5) 100%);
            z-index: 1;
        }
        
        .hero-content-wrapper {
            position: relative;
            z-index: 2;
        }
        
        /* Parallax effect on scroll */
        @media (prefers-reduced-motion: no-preference) {
            .hero-background {
                transition: transform 0.3s ease-out;
            }
        }
        
        /* Fallback gradient if image doesn't load */
        .hero-fallback-gradient {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 25%, #f093fb 50%, #4facfe 75%, #00f2fe 100%);
        }
        
        /* Custom scrollbar for premium feel */
        ::-webkit-scrollbar {
            width: 8px;
        }
        
        ::-webkit-scrollbar-track {
            background: #f5f5f7;
        }
        
        ::-webkit-scrollbar-thumb {
            background: #d2d2d7;
            border-radius: 4px;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: #a1a1a6;
        }
        
        /* Section dividers and patterns */
        .section-divider {
            height: 1px;
            background: linear-gradient(to right, transparent, rgba(0, 0, 0, 0.1), transparent);
            margin: 0 auto;
            max-width: 200px;
        }
        
        .section-divider-large {
            height: 2px;
            background: linear-gradient(to right, transparent, rgba(0, 0, 0, 0.15), transparent);
            margin: 0 auto;
            max-width: 400px;
        }
        
        /* Subtle pattern overlay */
        .pattern-overlay {
            background-image: 
                radial-gradient(circle at 2px 2px, rgba(0, 0, 0, 0.02) 1px, transparent 0);
            background-size: 40px 40px;
            position: absolute;
            inset: 0;
            pointer-events: none;
            opacity: 0.5;
        }
        
        /* Snowflake pattern for winter theme */
        .snowflake-pattern {
            background-image: 
                url("data:image/svg+xml,%3Csvg width='60' height='60' viewBox='0 0 60 60' xmlns='http://www.w3.org/2000/svg'%3E%3Cg fill='none' fill-rule='evenodd'%3E%3Cg fill='%23000000' fill-opacity='0.02'%3E%3Cpath d='M30 0l2 2-2 2-2-2zM30 54l2 2-2 2-2-2zM0 30l2-2 2 2-2 2zM54 30l2-2 2 2-2 2zM15.5 10.5l1.5 1.5-1.5 1.5-1.5-1.5zM42.5 37.5l1.5 1.5-1.5 1.5-1.5-1.5zM10.5 44.5l1.5-1.5 1.5 1.5-1.5 1.5zM48.5 6.5l1.5-1.5 1.5 1.5-1.5 1.5zM15.5 48.5l1.5 1.5-1.5 1.5-1.5-1.5zM42.5 21.5l1.5 1.5-1.5 1.5-1.5-1.5zM10.5 14.5l1.5-1.5 1.5 1.5-1.5 1.5zM48.5 52.5l1.5-1.5 1.5 1.5-1.5 1.5z'/%3E%3C/g%3E%3C/g%3E%3C/svg%3E");
            position: absolute;
            inset: 0;
            pointer-events: none;
            opacity: 0.03;
        }
        
        /* Enhanced Search Bar Styles */
        .autocomplete-item {
            display: flex;
            align-items: center;
            padding: 12px 20px;
            cursor: pointer;
            transition: background-color 0.15s ease;
            border-bottom: 1px solid #f3f4f6;
        }
        
        .autocomplete-item:last-child {
            border-bottom: none;
        }
        
        .autocomplete-item:hover,
        .autocomplete-item.selected {
            background-color: #f9fafb;
        }
        
        .autocomplete-item-icon {
            width: 40px;
            height: 40px;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 12px;
            flex-shrink: 0;
        }
        
        .autocomplete-item-icon.restaurant {
            background-color: #eff6ff;
            color: #3b82f6;
        }
        
        .autocomplete-item-icon.resort {
            background-color: #f0fdf4;
            color: #22c55e;
        }
        
        .autocomplete-item-icon.location {
            background-color: #fef3c7;
            color: #f59e0b;
        }
        
        .autocomplete-item-content {
            flex: 1;
            min-width: 0;
        }
        
        .autocomplete-item-title {
            font-weight: 500;
            color: #111827;
            margin-bottom: 2px;
            font-size: 15px;
        }
        
        .autocomplete-item-subtitle {
            font-size: 13px;
            color: #6b7280;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        .autocomplete-item-highlight {
            background-color: #fef3c7;
            padding: 0 2px;
            border-radius: 2px;
            font-weight: 600;
        }
        
        .recent-search-item {
            display: flex;
            align-items: center;
            padding: 10px 20px;
            cursor: pointer;
            transition: background-color 0.15s ease;
        }
        
        .recent-search-item:hover {
            background-color: #f9fafb;
        }
        
        .recent-search-item-icon {
            width: 32px;
            height: 32px;
            border-radius: 8px;
            background-color: #f3f4f6;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 12px;
            color: #6b7280;
        }
        
        .filter-chip.active {
            background-color: var(--accent-blue);
            color: white;
            border-color: var(--accent-blue);
        }
        
        /* Search icon animation */
        #searchIcon.focused {
            color: var(--accent-blue);
        }
        
        /* Smooth dropdown animation */
        #autocompleteDropdown {
            animation: slideDown 0.2s ease-out;
        }
        
        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        /* Location Permission Modal */
        .modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(4px);
            z-index: 100;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }
        
        .modal-overlay.active {
            opacity: 1;
            pointer-events: all;
        }
        
        .modal-content {
            background: white;
            border-radius: 18px;
            padding: 2rem;
            max-width: 500px;
            width: 90%;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
            transform: scale(0.95);
            transition: transform 0.3s ease;
        }
        
        .modal-overlay.active .modal-content {
            transform: scale(1);
        }
        
        /* Print Styles */
        @media print {
            nav, 
            footer, 
            #loadingOverlay,
            .map-filter-btn,
            button:not(.print-keep),
            #findMyLocationBtn {
                display: none !important;
            }
            
            body {
                background: white;
                color: black;
            }
            
            section {
                page-break-inside: avoid;
                margin-bottom: 2rem;
            }
            
            h1, h2, h3 {
                page-break-after: avoid;
            }
            
            a[href^="http"]:after {
                content: " (" attr(href) ")";
                font-size: 0.8em;
                color: #666;
            }
            
            .restaurant-card-link,
            .resort-card-link {
                page-break-inside: avoid;
                border: 1px solid #ddd;
                margin-bottom: 1rem;
            }
        }
        
        /* Enhanced Restaurant Card Styles */
        .restaurant-card-enhanced {
            position: relative;
            background: white;
            border-radius: 20px;
            overflow: hidden;
            box-shadow: 0 4px 12px rgba(0,0,0,0.08), 0 1px 3px rgba(0,0,0,0.05);
            border: 1px solid rgba(0,0,0,0.04);
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            cursor: pointer;
            height: 100%;
            display: flex;
            flex-direction: column;
        }
        .restaurant-card-enhanced:hover {
            transform: translateY(-6px);
            box-shadow: 0 20px 50px rgba(0,0,0,0.12), 0 8px 16px rgba(0,0,0,0.08);
            border-color: rgba(0,0,0,0.08);
        }
        .card-image-wrapper {
            position: relative;
            aspect-ratio: 16/9;
            overflow: hidden;
        }
        .card-image-wrapper img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transition: transform 0.6s ease;
        }
        .restaurant-card-enhanced:hover .card-image-wrapper img {
            transform: scale(1.1);
        }
        
        /* Favorites button styling for resort cards */
        .favorite-button {
            transition: all 0.2s ease;
        }
        
        .favorite-button:hover svg {
            transform: scale(1.1);
        }
        
        .favorite-button.favorited svg {
            animation: favoritePulse 0.3s ease;
        }
        
        @keyframes favoritePulse {
            0%, 100% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.2);
            }
        }
        
        /* Logo overlay container - hidden by default */
        .resort-logo-overlay-container {
            display: none !important;
        }
        
        .resort-logo-overlay-container[style*="flex"] {
            display: flex !important;
        }
        .card-hover-overlay {
            position: absolute;
            inset: 0;
            background: linear-gradient(to top, rgba(0,0,0,0.7) 0%, transparent 100%);
            opacity: 0;
            transition: opacity 0.3s;
            display: flex;
            align-items: flex-end;
            padding: 20px;
            color: white;
            pointer-events: none;
        }
        .restaurant-card-enhanced:hover .card-hover-overlay {
            opacity: 1;
        }
        .card-hover-info {
            width: 100%;
        }
        .card-hover-rating {
            font-size: 24px;
            font-weight: 700;
            margin-bottom: 4px;
        }
        .card-hover-price {
            font-size: 16px;
            opacity: 0.9;
        }
        .card-badge-container {
            position: absolute;
            top: 12px;
            left: 12px;
            z-index: 10;
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }
        .card-badge-new {
            background: linear-gradient(135deg, #10b981, #059669);
            color: white;
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 11px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            box-shadow: 0 2px 8px rgba(16, 185, 129, 0.4);
        }
        .card-badge-trending {
            background: linear-gradient(135deg, #8b5cf6, #7c3aed);
            color: white;
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 11px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            box-shadow: 0 2px 8px rgba(139, 92, 246, 0.4);
        }
        .quick-view-btn {
            position: absolute;
            bottom: 16px;
            right: 16px;
            background: white;
            color: var(--accent-blue);
            padding: 10px 20px;
            border-radius: 25px;
            font-weight: 600;
            font-size: 14px;
            opacity: 0;
            transform: translateY(10px);
            transition: all 0.3s;
            z-index: 11;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            pointer-events: auto;
            border: none;
            cursor: pointer;
        }
        .restaurant-card-enhanced:hover .quick-view-btn {
            opacity: 1;
            transform: translateY(0);
        }
        .quick-view-btn:hover {
            background: var(--accent-blue);
            color: white;
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(59, 130, 246, 0.4);
        }
        .photo-count {
            position: absolute;
            top: 12px;
            right: 12px;
            background: rgba(0,0,0,0.6);
            color: white;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 4px;
            z-index: 10;
            backdrop-filter: blur(10px);
        }
        .restaurant-badge {
            display: inline-flex;
            align-items: center;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .badge-featured {
            background: linear-gradient(135deg, #3b82f6, #2563eb);
            color: white;
        }
        .badge-popular {
            background: linear-gradient(135deg, #8b5cf6, #7c3aed);
            color: white;
        }
        .availability-badge {
            display: inline-block;
            padding: 6px 12px;
            border-radius: 8px;
            font-size: 12px;
            font-weight: 600;
            letter-spacing: 0.3px;
        }
        .availability-open {
            background: linear-gradient(135deg, #d1fae5, #a7f3d0);
            color: #065f46;
            box-shadow: 0 1px 3px rgba(16, 185, 129, 0.2);
        }
        .availability-closed {
            background: linear-gradient(135deg, #fee2e2, #fecaca);
            color: #991b1b;
            box-shadow: 0 1px 3px rgba(239, 68, 68, 0.2);
        }
        .review-snippet {
            font-size: 13px;
            color: #6b7280;
            font-style: italic;
            margin: 8px 0;
            line-height: 1.5;
        }
        .social-proof {
            font-size: 12px;
            color: #6b7280;
            margin: 8px 0;
        }
        .quick-actions {
            display: flex;
            gap: 8px;
            margin: 12px 0;
            flex-wrap: wrap;
        }
        .quick-action-btn {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
            background: #f3f4f6;
            color: #374151;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 500;
            text-decoration: none;
            transition: all 0.2s;
        }
        .quick-action-btn:hover {
            background: var(--accent-blue);
            color: white;
        }
        .last-updated {
            font-size: 11px;
            color: #9ca3af;
            margin-top: 8px;
        }
        .swipeable-card-mobile {
            position: relative;
            touch-action: pan-y;
        }
        .share-btn {
            padding: 8px;
            border-radius: 8px;
            background: #f3f4f6;
            border: none;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .share-btn:hover {
            background: #e5e7eb;
        }
        .share-btn svg {
            width: 18px;
            height: 18px;
        }
        .line-clamp-2 {
            display: -webkit-box;
            -webkit-line-clamp: 2;
            line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }
        
        /* Preview Modal */
        .preview-modal {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.6);
            backdrop-filter: blur(8px);
            z-index: 1000;
            display: none;
            align-items: center;
            justify-content: center;
            padding: 20px;
            animation: fadeIn 0.2s ease-out;
        }
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        .preview-modal.active {
            display: flex;
        }
        .preview-content {
            background: white;
            border-radius: 24px;
            max-width: 650px;
            width: 100%;
            max-height: 85vh;
            overflow-y: auto;
            position: relative;
            box-shadow: 0 25px 70px rgba(0,0,0,0.4);
            animation: slideUp 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translateY(20px) scale(0.95);
            }
            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }
        #previewContent {
            padding: 32px;
        }
        .preview-content .close-btn {
            position: absolute;
            top: 16px;
            right: 16px;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background: rgba(0,0,0,0.05);
            border: none;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
            z-index: 10;
        }
        .preview-content .close-btn:hover {
            background: rgba(0,0,0,0.1);
            transform: scale(1.1);
        }
    </style>
</head>
<body class="bg-white text-gray-900 antialiased">
    
    <!-- Loading Overlay -->
    <div id="loadingOverlay" class="loading-overlay">
        <div class="text-center">
            <div class="loading-spinner"></div>
            <p class="mt-4 text-gray-600 font-medium">Loading...</p>
        </div>
    </div>
    
    <!-- 1. Top Navigation Bar -->
    <!-- Design Decision: Sticky, frosted glass effect for premium Apple aesthetic -->
    <nav class="fixed top-0 left-0 right-0 z-50 frosted-glass border-b border-blue-300/50">
        <div class="max-w-7xl mx-auto px-6 sm:px-8">
            <div class="flex items-center justify-between h-14">
                <!-- Logo - Left aligned -->
                <div class="flex-shrink-0">
                    <a href="index.html" class="text-2xl font-semibold hover:opacity-80 transition-opacity duration-300">
                        <span class="bg-white text-[var(--accent-blue)] px-1">SNO</span><span class="text-white">GRUB</span>
                    </a>
                </div>
                
                <!-- Navigation Menu - Right aligned -->
                <!-- Design Decision: Minimal spacing, subtle hover states with opacity fade -->
                <div class="hidden md:flex items-center space-x-8">
                    <a href="resorts.html" class="text-sm font-medium text-white hover:text-blue-100 transition-colors duration-200">
                        Resorts
                    </a>
                    <a href="restaurants.html" class="text-sm font-medium text-white hover:text-blue-100 transition-colors duration-200">
                        Restaurants
                    </a>
                    <a href="map.html" class="text-sm font-medium text-white hover:text-blue-100 transition-colors duration-200">
                        Map
                    </a>
                    <a href="blog.html" class="text-sm font-medium text-white hover:text-blue-100 transition-colors duration-200">
                        Blog
                    </a>
                    <a href="favorites.html" class="text-sm font-medium text-white hover:text-blue-100 transition-colors duration-200">
                        Favorites
                    </a>
                    <a href="trips.html" class="text-sm font-medium text-white hover:text-blue-100 transition-colors duration-200">
                        Trips
                    </a>
                </div>
                
                <!-- Mobile Menu Button -->
                <button id="mobileMenuButton" class="md:hidden text-white hover:text-blue-100 transition-colors" aria-label="Menu">
                    <svg id="menuIcon" class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"></path>
                    </svg>
                    <svg id="closeIcon" class="w-6 h-6 hidden" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                    </svg>
                </button>
            </div>
            
            <!-- Mobile Menu Dropdown -->
            <div id="mobileMenu" class="hidden md:hidden border-t border-blue-300/50 bg-blue-600/95 backdrop-blur-lg" role="menu" aria-labelledby="mobileMenuButton">
                <div class="px-6 py-4 space-y-4">
                    <a href="resorts.html" class="block text-sm font-medium text-white hover:text-blue-100 transition-colors duration-200" role="menuitem">Resorts</a>
                    <a href="restaurants.html" class="block text-sm font-medium text-white hover:text-blue-100 transition-colors duration-200" role="menuitem">Restaurants</a>
                    <a href="map.html" class="block text-sm font-medium text-white hover:text-blue-100 transition-colors duration-200" role="menuitem">Map</a>
                    <a href="blog.html" class="block text-sm font-medium text-white hover:text-blue-100 transition-colors duration-200" role="menuitem">Blog</a>
                    <a href="favorites.html" class="block text-sm font-medium text-white hover:text-blue-100 transition-colors duration-200" role="menuitem">Favorites</a>
                    <a href="trips.html" class="block text-sm font-medium text-white hover:text-blue-100 transition-colors duration-200" role="menuitem">Trips</a>
                </div>
            </div>
        </div>
    </nav>
    
    <!-- Error Message Toast -->
    <div id="errorMessage" class="fixed top-20 right-6 z-50 max-w-md hidden" role="alert" aria-live="assertive">
        <div class="bg-red-50 border-l-4 border-red-400 p-4 rounded-lg shadow-lg">
            <div class="flex items-start">
                <div class="flex-shrink-0">
                    <svg class="h-5 w-5 text-red-400" fill="currentColor" viewBox="0 0 20 20">
                        <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z" clip-rule="evenodd"/>
                    </svg>
                </div>
                <div class="ml-3 flex-1">
                    <p id="errorText" class="text-sm font-medium text-red-800"></p>
                </div>
                <div class="ml-4 flex-shrink-0">
                    <button onclick="document.getElementById('errorMessage').classList.add('hidden')" class="text-red-400 hover:text-red-600 focus:outline-none">
                        <svg class="h-5 w-5" fill="currentColor" viewBox="0 0 20 20">
                            <path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"/>
                        </svg>
                    </button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Success Message Toast -->
    <div id="successMessage" class="fixed top-20 right-6 z-50 max-w-md hidden" role="alert" aria-live="polite">
        <div class="bg-green-50 border-l-4 border-green-400 p-4 rounded-lg shadow-lg">
            <div class="flex items-start">
                <div class="flex-shrink-0">
                    <svg class="h-5 w-5 text-green-400" fill="currentColor" viewBox="0 0 20 20">
                        <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd"/>
                    </svg>
                </div>
                <div class="ml-3 flex-1">
                    <p id="successText" class="text-sm font-medium text-green-800"></p>
                </div>
                <div class="ml-4 flex-shrink-0">
                    <button onclick="document.getElementById('successMessage').classList.add('hidden')" class="text-green-400 hover:text-green-600 focus:outline-none">
                        <svg class="h-5 w-5" fill="currentColor" viewBox="0 0 20 20">
                            <path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"/>
                        </svg>
                    </button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- 2. Hero Section -->
    <!-- Design Decision: Large, bold typography with hero background image and parallax effect -->
    <section class="pt-32 pb-24 px-6 sm:px-8 relative overflow-hidden min-h-[600px] flex items-center" id="heroSection">
        <!-- Hero Background Image with Parallax -->
        <!-- Using Unsplash for high-quality ski resort dining images (free, no API key needed) -->
        <div class="hero-background hero-fallback-gradient" 
             style="background-image: url('https://images.unsplash.com/photo-1506905925346-21bda4d32df4?ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D&auto=format&fit=crop&w=2070&q=80');"
             id="heroBackground">
        </div>
        
        <!-- Dark overlay for text readability -->
        <div class="hero-background-overlay"></div>
        
        <!-- Subtle mountain silhouette overlay (very subtle, for texture) -->
        <div class="absolute inset-0 opacity-5 pointer-events-none z-[1]">
            <svg class="w-full h-full" viewBox="0 0 1200 400" preserveAspectRatio="none">
                <path d="M0,400 L200,250 L400,300 L600,200 L800,280 L1000,150 L1200,200 L1200,400 Z" fill="currentColor" class="text-white"/>
            </svg>
        </div>
        
        <div class="max-w-4xl mx-auto text-center hero-content-wrapper w-full">
            <!-- Trust Indicator Badge -->
            <div class="mb-6 inline-flex items-center gap-2 px-4 py-2 bg-white/20 backdrop-blur-md rounded-full border border-white/30">
                <svg class="w-5 h-5 text-white" fill="currentColor" viewBox="0 0 20 20">
                    <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd"/>
                </svg>
                <span class="text-sm font-medium text-white">Join 50,000+ skiers discovering great food</span>
            </div>
            
            <!-- Value Proposition - Above headline -->
            <p class="text-sm sm:text-base font-medium text-white/80 mb-4 uppercase tracking-wider drop-shadow-md">
                Your Guide to Ski Resort Dining
            </p>
            
            <!-- Main Headline - Reduced size, more refined -->
            <h1 class="text-4xl sm:text-5xl md:text-6xl font-semibold text-white mb-6 tracking-tight drop-shadow-lg leading-tight">
                Discover the Best Eats in North American Ski Resorts
            </h1>
            
            <!-- Sub-headline - Elegant, descriptive with white/light text -->
            <p class="text-lg sm:text-xl text-white/90 mb-10 font-light max-w-2xl mx-auto leading-relaxed drop-shadow-md">
                From cozy lodges to lively après-ski bars — find your next favorite spot.
            </p>
            
            <!-- Enhanced Search Bar - Apple-style with autocomplete -->
            <!-- Design Decision: Large, prominent search with live suggestions, recent searches, and quick filters -->
            <div class="max-w-3xl mx-auto mb-8">
                <div class="relative" id="searchContainer">
                    <form action="restaurants.html" method="get" class="relative">
                        <div class="relative">
                            <input 
                                type="text" 
                                name="q"
                                id="searchInput"
                                autocomplete="off"
                                placeholder="Search by town, state, city, resort name, or restaurant name..." 
                                class="w-full px-6 py-5 pl-16 pr-32 bg-white border-2 border-gray-200 rounded-2xl text-gray-900 placeholder-gray-400 focus:outline-none focus:ring-4 focus:ring-[var(--accent-blue)] focus:ring-opacity-20 focus:border-[var(--accent-blue)] transition-all duration-300 shadow-lg hover:shadow-xl text-lg"
                            >
                            <!-- Dynamic Search Icon -->
                            <div id="searchIcon" class="absolute left-6 top-1/2 transform -translate-y-1/2 w-6 h-6 text-gray-400 transition-colors duration-200">
                                <svg id="searchIconSvg" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"></path>
                                </svg>
                            </div>
                            <!-- Clear Button (shown when there's text) -->
                            <button 
                                type="button"
                                id="clearSearchBtn"
                                class="absolute right-24 top-1/2 transform -translate-y-1/2 w-8 h-8 flex items-center justify-center text-gray-400 hover:text-gray-600 rounded-full hover:bg-gray-100 transition-all duration-200 opacity-0 pointer-events-none"
                                aria-label="Clear search"
                            >
                                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                                </svg>
                            </button>
                            <!-- Submit Button -->
                            <button 
                                type="submit" 
                                class="absolute right-2 top-1/2 transform -translate-y-1/2 px-6 py-2.5 bg-[var(--accent-blue)] text-white rounded-xl text-sm font-semibold hover:opacity-90 hover:shadow-lg transition-all duration-200 shadow-md"
                            >
                                Search
                            </button>
                        </div>
                    </form>
                    
                    <!-- Autocomplete Dropdown -->
                    <div 
                        id="autocompleteDropdown" 
                        class="absolute top-full left-0 right-0 mt-2 bg-white rounded-2xl shadow-2xl border border-gray-100 overflow-hidden z-50 max-h-96 overflow-y-auto hidden"
                    >
                        <!-- Recent Searches Section -->
                        <div id="recentSearchesSection" class="hidden">
                            <div class="px-4 py-3 bg-gray-50 border-b border-gray-100">
                                <div class="flex items-center justify-between">
                                    <h3 class="text-xs font-semibold text-gray-500 uppercase tracking-wider">Recent Searches</h3>
                                    <button id="clearRecentBtn" class="text-xs text-[var(--accent-blue)] hover:underline">Clear</button>
                                </div>
                            </div>
                            <div id="recentSearchesList" class="py-2"></div>
                        </div>
                        
                        <!-- Suggestions Section -->
                        <div id="suggestionsSection">
                            <div id="suggestionsList" class="py-2"></div>
                        </div>
                        
                        <!-- No Results -->
                        <div id="noResults" class="hidden px-6 py-8 text-center">
                            <svg class="w-12 h-12 text-gray-300 mx-auto mb-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.172 16.172a4 4 0 015.656 0M9 10h.01M15 10h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                            </svg>
                            <p class="text-gray-500 text-sm">No results found</p>
                            <p class="text-gray-400 text-xs mt-1">Try a different search term</p>
                        </div>
                    </div>
                </div>
                
                <!-- Quick Filter Chips -->
                <div class="mt-4 flex flex-wrap items-center justify-center gap-2">
                    <span class="text-sm text-gray-500 mr-2">Quick filters:</span>
                    <button class="filter-chip px-4 py-2 bg-white border border-gray-200 rounded-full text-sm text-gray-700 hover:bg-gray-50 hover:border-[var(--accent-blue)] hover:text-[var(--accent-blue)] transition-all duration-200 shadow-sm" data-filter="fine-dining">
                        Fine Dining
                    </button>
                    <button class="filter-chip px-4 py-2 bg-white border border-gray-200 rounded-full text-sm text-gray-700 hover:bg-gray-50 hover:border-[var(--accent-blue)] hover:text-[var(--accent-blue)] transition-all duration-200 shadow-sm" data-filter="casual">
                        Casual
                    </button>
                    <button class="filter-chip px-4 py-2 bg-white border border-gray-200 rounded-full text-sm text-gray-700 hover:bg-gray-50 hover:border-[var(--accent-blue)] hover:text-[var(--accent-blue)] transition-all duration-200 shadow-sm" data-filter="apres-ski">
                        Après-Ski
                    </button>
                    <button class="filter-chip px-4 py-2 bg-white border border-gray-200 rounded-full text-sm text-gray-700 hover:bg-gray-50 hover:border-[var(--accent-blue)] hover:text-[var(--accent-blue)] transition-all duration-200 shadow-sm" data-filter="family-friendly">
                        Family Friendly
                    </button>
                    <button class="filter-chip px-4 py-2 bg-white border border-gray-200 rounded-full text-sm text-gray-700 hover:bg-gray-50 hover:border-[var(--accent-blue)] hover:text-[var(--accent-blue)] transition-all duration-200 shadow-sm" data-filter="$$">
                        Budget Friendly
                    </button>
                </div>
            </div>
            
            <!-- CTA Buttons - Pill-shaped, Apple-style -->
            <!-- Design Decision: Primary accent button + secondary outline button -->
            <div class="flex flex-col sm:flex-row items-center justify-center gap-4">
                <a href="resorts.html" class="px-8 py-3 bg-[var(--accent-blue)] text-white rounded-full font-medium hover:opacity-90 transition-opacity duration-300 shadow-sm hover:shadow-md">
                    Explore Resorts
                </a>
                <button id="findNearMeBtn" class="px-8 py-3 bg-white text-gray-900 rounded-full font-medium border border-gray-300 hover:bg-gray-50 transition-colors duration-300 shadow-sm hover:shadow-md">
                    Find Restaurants Near Me
                </button>
            </div>
        </div>
    </section>
    
    <!-- 3. Featured Resort Section -->
    <!-- Design Decision: Clean Apple card style with soft shadows, thin borders, large images -->
    <section id="resorts" class="py-24 px-6 sm:px-8 bg-white relative">
        <!-- Subtle pattern overlay -->
        <div class="pattern-overlay"></div>
        <div class="max-w-7xl mx-auto relative z-10">
            <!-- Section Header -->
            <div class="text-center mb-16">
                <div class="section-divider mb-8"></div>
                <h2 class="text-4xl sm:text-5xl font-semibold text-gray-900 mb-4 tracking-tight">
                    Resorts
                </h2>
                <p class="text-xl text-gray-600 font-light max-w-2xl mx-auto mb-6">
                    Explore dining at North America's premier ski destinations.
                </p>
                <div class="section-divider"></div>
            </div>
            
            <!-- Two Column Layout: Featured and Closest Resorts -->
            <div class="grid grid-cols-1 lg:grid-cols-2 gap-8 lg:gap-12">
                <!-- Featured Resort Column -->
                <div>
                    <h3 id="featuredResortTitle" class="text-2xl font-semibold text-gray-900 mb-6">
                        Featured Resort
                    </h3>
                    <div id="featuredResortGrid" class="grid grid-cols-1 gap-6">
                        <!-- Skeleton loader shown initially -->
                        <div class="skeleton-card">
                            <div class="skeleton-image"></div>
                            <div class="p-6">
                                <div class="skeleton skeleton-text short mb-2"></div>
                                <div class="skeleton skeleton-text medium mb-4"></div>
                                <div class="skeleton skeleton-button"></div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Closest Resort Column -->
                <div>
                    <h3 id="closestResortTitle" class="text-2xl font-semibold text-gray-900 mb-6">
                        Closest Resort
                    </h3>
                    <div id="closestResortGrid" class="grid grid-cols-1 gap-6">
                        <!-- Skeleton loader shown initially -->
                        <div class="skeleton-card">
                            <div class="skeleton-image"></div>
                            <div class="p-6">
                                <div class="skeleton skeleton-text short mb-2"></div>
                                <div class="skeleton skeleton-text medium mb-4"></div>
                                <div class="skeleton skeleton-button"></div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </section>
    
    <!-- 4. Featured Places to Eat Section -->
    <!-- Design Decision: Apple product grid style - clean, bold photography, thin borders -->
    <section id="restaurants" class="py-24 px-6 sm:px-8 bg-gray-50 relative">
        <!-- Snowflake pattern for winter theme -->
        <div class="snowflake-pattern"></div>
        <div class="max-w-7xl mx-auto relative z-10">
            <!-- Section Header -->
            <div class="text-center mb-12">
                <div class="section-divider mb-8"></div>
                <h2 id="restaurantsSectionTitle" class="text-4xl sm:text-5xl font-semibold text-gray-900 mb-4 tracking-tight">
                    Closest places to grab a bite
                </h2>
                <p id="restaurantsSectionDescription" class="text-xl text-gray-600 font-light max-w-2xl mx-auto mb-6">
                    Discover exceptional dining experiences at ski resorts across North America.
                </p>
                <div class="section-divider"></div>
                
                <!-- Filter Buttons -->
                <!-- Design Decision: Apple-style filter pills with active states -->
                <div class="flex flex-wrap items-center justify-center gap-3 mb-8">
                    <button class="filter-btn active px-5 py-2 bg-[var(--accent-blue)] text-white rounded-full text-sm font-medium hover:opacity-90 transition-opacity duration-200" data-filter="all">
                        All
                    </button>
                    <button class="filter-btn px-5 py-2 bg-white text-gray-700 border border-gray-300 rounded-full text-sm font-medium hover:bg-gray-50 transition-colors duration-200" data-filter="restaurant">
                        Restaurants
                    </button>
                    <button class="filter-btn px-5 py-2 bg-white text-gray-700 border border-gray-300 rounded-full text-sm font-medium hover:bg-gray-50 transition-colors duration-200" data-filter="bar">
                        Après Bars
                    </button>
                    <button class="filter-btn px-5 py-2 bg-white text-gray-700 border border-gray-300 rounded-full text-sm font-medium hover:bg-gray-50 transition-colors duration-200" data-filter="cafe">
                        Cafés
                    </button>
                </div>
            </div>
            
            <!-- Restaurant Grid -->
            <!-- Design Decision: Clean grid with restaurant cards, similar to Apple's product showcase -->
            <div id="restaurantGrid" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                <!-- Skeleton loaders shown initially -->
                <div class="skeleton-card">
                    <div class="skeleton-image"></div>
                    <div class="p-6">
                        <div class="flex items-start justify-between mb-2">
                            <div class="skeleton skeleton-text short"></div>
                            <div class="skeleton" style="width: 20px; height: 20px; border-radius: 50%;"></div>
                        </div>
                        <div class="skeleton skeleton-text medium mb-3"></div>
                        <div class="flex items-center justify-between">
                            <div class="skeleton" style="width: 80px; height: 24px; border-radius: 12px;"></div>
                            <div class="skeleton skeleton-button"></div>
                        </div>
                    </div>
                </div>
                <div class="skeleton-card">
                    <div class="skeleton-image"></div>
                    <div class="p-6">
                        <div class="flex items-start justify-between mb-2">
                            <div class="skeleton skeleton-text short"></div>
                            <div class="skeleton" style="width: 20px; height: 20px; border-radius: 50%;"></div>
                        </div>
                        <div class="skeleton skeleton-text medium mb-3"></div>
                        <div class="flex items-center justify-between">
                            <div class="skeleton" style="width: 80px; height: 24px; border-radius: 12px;"></div>
                            <div class="skeleton skeleton-button"></div>
                        </div>
                    </div>
                </div>
                <div class="skeleton-card">
                    <div class="skeleton-image"></div>
                    <div class="p-6">
                        <div class="flex items-start justify-between mb-2">
                            <div class="skeleton skeleton-text short"></div>
                            <div class="skeleton" style="width: 20px; height: 20px; border-radius: 50%;"></div>
                        </div>
                        <div class="skeleton skeleton-text medium mb-3"></div>
                        <div class="flex items-center justify-between">
                            <div class="skeleton" style="width: 80px; height: 24px; border-radius: 12px;"></div>
                            <div class="skeleton skeleton-button"></div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- More Button -->
            <div class="text-center mt-8">
                <button id="loadMoreRestaurantsBtn" class="px-6 py-3 bg-white text-gray-700 border border-gray-300 rounded-full text-sm font-medium hover:bg-gray-50 transition-colors duration-200 hidden">
                    View More
                </button>
            </div>
        </div>
    </section>
    
    <!-- How It Works Section -->
    <!-- Design Decision: Clean, step-by-step guide with icons and minimal design -->
    <section class="py-24 px-6 sm:px-8 bg-white relative">
        <!-- Subtle pattern overlay -->
        <div class="pattern-overlay"></div>
        <div class="max-w-7xl mx-auto relative z-10">
            <div class="text-center mb-16">
                <div class="section-divider mb-8"></div>
                <h2 class="text-4xl sm:text-5xl font-semibold text-gray-900 mb-4 tracking-tight">
                    How It Works
                </h2>
                <p class="text-xl text-gray-600 font-light max-w-2xl mx-auto mb-6">
                    Find the perfect dining spot in three simple steps.
                </p>
                <div class="section-divider"></div>
            </div>
            
            <div class="grid grid-cols-1 md:grid-cols-3 gap-8">
                <!-- Step 1 -->
                <div class="text-center">
                    <div class="w-16 h-16 bg-[var(--accent-blue)] rounded-full flex items-center justify-center mx-auto mb-6">
                        <span class="text-2xl font-semibold text-white">1</span>
                    </div>
                    <h3 class="text-xl font-semibold text-gray-900 mb-3">Choose a Resort</h3>
                    <p class="text-gray-600 leading-relaxed">
                        Browse our curated list of North America's premier ski resorts.
                    </p>
                </div>
                
                <!-- Step 2 -->
                <div class="text-center">
                    <div class="w-16 h-16 bg-[var(--accent-blue)] rounded-full flex items-center justify-center mx-auto mb-6">
                        <span class="text-2xl font-semibold text-white">2</span>
                    </div>
                    <h3 class="text-xl font-semibold text-gray-900 mb-3">Explore Options</h3>
                    <p class="text-gray-600 leading-relaxed">
                        Discover restaurants, bars, and cafés with detailed information and reviews.
                    </p>
                </div>
                
                <!-- Step 3 -->
                <div class="text-center">
                    <div class="w-16 h-16 bg-[var(--accent-blue)] rounded-full flex items-center justify-center mx-auto mb-6">
                        <span class="text-2xl font-semibold text-white">3</span>
                    </div>
                    <h3 class="text-xl font-semibold text-gray-900 mb-3">Plan Your Visit</h3>
                    <p class="text-gray-600 leading-relaxed">
                        Get directions, view menus, and make reservations all in one place.
                    </p>
                </div>
            </div>
        </div>
    </section>
    
    <!-- Preview Modal for Quick View -->
    <div id="previewModal" class="preview-modal" role="dialog" aria-labelledby="previewModalTitle" aria-modal="true">
        <div class="preview-content">
            <button id="closePreviewBtn" class="absolute top-4 right-4 w-8 h-8 flex items-center justify-center rounded-full hover:bg-gray-100" onclick="document.getElementById('previewModal').classList.remove('active')" aria-label="Close preview">
                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                </svg>
            </button>
            <div id="previewContent" class="p-6"></div>
        </div>
    </div>
    
    <!-- 5. Footer -->
    <!-- Design Decision: Simple, thin, minimalist Apple-like footer -->
    <footer class="py-12 px-6 sm:px-8 border-t border-gray-200 bg-white">
        <!-- Google Maps Attribution (Required by Google Maps Platform Terms of Service) -->
        <div class="max-w-7xl mx-auto mb-6 text-center">
            <p class="text-xs text-gray-500">
                Map data &copy; <a href="https://www.google.com/maps" target="_blank" rel="noopener noreferrer" class="text-gray-600 hover:text-[var(--accent-blue)]">Google</a>
                &copy; <a href="https://www.openstreetmap.org/copyright" target="_blank" rel="noopener noreferrer" class="text-gray-600 hover:text-[var(--accent-blue)]">OpenStreetMap</a> contributors
            </p>
        </div>
        <div class="max-w-7xl mx-auto">
            <div class="grid grid-cols-1 md:grid-cols-4 gap-8 mb-8">
                <!-- Brand Column -->
                <div>
                    <h3 class="text-lg font-semibold text-gray-900 mb-4"><span class="bg-[var(--accent-blue)] text-white px-1">SNO</span><span class="text-[var(--accent-blue)]">GRUB</span></h3>
                    <p class="text-sm text-gray-600 leading-relaxed">
                        Discover the best dining experiences at ski resorts across North America.
                    </p>
                </div>
                
                <!-- Quick Links -->
                <div>
                    <h4 class="text-sm font-semibold text-gray-900 mb-4">Quick Links</h4>
                    <ul class="space-y-2">
                        <li><a href="#resorts" class="text-sm text-gray-600 hover:text-gray-900 transition-colors duration-200">Resorts</a></li>
                        <li><a href="restaurants.html" class="text-sm text-gray-600 hover:text-gray-900 transition-colors duration-200">Restaurants</a></li>
                    </ul>
                </div>
                
                <!-- Company -->
                <div>
                    <h4 class="text-sm font-semibold text-gray-900 mb-4">Company</h4>
                    <ul class="space-y-2">
                        <li><a href="#" class="text-sm text-gray-600 hover:text-gray-900 transition-colors duration-200">About</a></li>
                        <li><a href="#" class="text-sm text-gray-600 hover:text-gray-900 transition-colors duration-200">Contact</a></li>
                        <li><a href="#" class="text-sm text-gray-600 hover:text-gray-900 transition-colors duration-200">Submit Restaurant</a></li>
                    </ul>
                </div>
                
                <!-- Legal -->
                <div>
                    <h4 class="text-sm font-semibold text-gray-900 mb-4">Legal</h4>
                    <ul class="space-y-2">
                        <li><a href="#" class="text-sm text-gray-600 hover:text-gray-900 transition-colors duration-200">Privacy</a></li>
                        <li><a href="#" class="text-sm text-gray-600 hover:text-gray-900 transition-colors duration-200">Terms</a></li>
                    </ul>
                </div>
            </div>
            
            <!-- Bottom Bar -->
            <div class="pt-8 border-t border-gray-200">
                <div class="flex flex-col md:flex-row justify-between items-center">
                    <p class="text-sm text-gray-600 mb-4 md:mb-0">
                        © 2025 <span class="bg-[var(--accent-blue)] text-white px-1">SNO</span><span class="text-[var(--accent-blue)]">GRUB</span>. All rights reserved.
                    </p>
                    <!-- OpenStreetMap Attribution (Required by ODbL License) -->
                    <p class="text-xs text-gray-500">
                        Map data &copy; <a href="https://www.openstreetmap.org/copyright" target="_blank" rel="noopener noreferrer" class="text-gray-600 hover:text-[var(--accent-blue)] underline">OpenStreetMap</a> contributors
                        ${isMapillary ? ' | Street imagery &copy; <a href="https://www.mapillary.com" target="_blank" rel="noopener noreferrer" class="text-gray-600 hover:text-[var(--accent-blue)] underline">Mapillary</a>' : ''}
                    </p>
                    <div class="flex space-x-6">
                        <a href="#" class="text-sm text-gray-600 hover:text-gray-900 transition-colors duration-200">About</a>
                        <a href="#" class="text-sm text-gray-600 hover:text-gray-900 transition-colors duration-200">Contact</a>
                        <a href="#" class="text-sm text-gray-600 hover:text-gray-900 transition-colors duration-200">Privacy</a>
                        <a href="#" class="text-sm text-gray-600 hover:text-gray-900 transition-colors duration-200">Terms</a>
                        <a href="#" class="text-sm text-gray-600 hover:text-gray-900 transition-colors duration-200">Submit Restaurant</a>
                    </div>
                </div>
            </div>
        </div>
    </footer>
    
    <!-- Location Permission Modal -->
    <!-- Design Decision: Apple-style modal with clear, friendly messaging -->
    <div id="locationModal" class="modal-overlay">
        <div class="modal-content">
            <div class="text-center mb-6">
                <div class="w-16 h-16 bg-[var(--accent-blue)] rounded-full flex items-center justify-center mx-auto mb-4">
                    <svg class="w-8 h-8 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17.657 16.657L13.414 20.9a1.998 1.998 0 01-2.827 0l-4.244-4.243a8 8 0 1111.314 0z"></path>
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 11a3 3 0 11-6 0 3 3 0 016 0z"></path>
                    </svg>
                </div>
                <h3 class="text-2xl font-semibold text-gray-900 mb-2">
                    Find Restaurants Near You
                </h3>
                <p class="text-gray-600 leading-relaxed">
                    We can show you the closest dining options at ski resorts, or you can explore places for your next trip.
                </p>
            </div>
            
            <div class="space-y-3">
                <button id="allowLocationBtn" class="w-full px-6 py-3 bg-[var(--accent-blue)] text-white rounded-full font-medium hover:opacity-90 transition-opacity duration-300">
                    Use My Location
                </button>
                <button id="exploreBtn" class="w-full px-6 py-3 bg-white text-gray-900 rounded-full font-medium border border-gray-300 hover:bg-gray-50 transition-colors duration-300">
                    Just Exploring
                </button>
                <button id="cancelModalBtn" class="w-full px-6 py-2 text-gray-600 text-sm hover:text-gray-900 transition-colors duration-200">
                    Cancel
                </button>
            </div>
        </div>
    </div>
    
    <!-- Load Restaurant Data -->
    <!-- Load Universal Resort Card Component -->
    <script src="js/resort-card-universal.js"></script>
    <script src="data.js" onerror="
        console.error('Failed to load data.js');
        if (typeof skiEatsData === 'undefined') {
            window.skiEatsData = { resorts: [], restaurants: [] };
            setTimeout(function() {
                var errorMsg = document.getElementById('errorMessage');
                var errorText = document.getElementById('errorText');
                if (errorMsg && errorText) {
                    errorText.innerHTML = '<strong>Data Failed to Load</strong><br><span class=\'text-xs mt-1 block\'>Please check your internet connection and refresh the page.</span>';
                    errorMsg.classList.remove('hidden');
                }
            }, 100);
        }
    "></script>
    <!-- Home Base Functionality -->
    <script src="js/homebase.js"></script>
    <script src="js/homebase-bar.js"></script>
    
    <!-- Toggle Home Base Function -->
    <script>
        // Global function to toggle home base for a resort
        window.toggleResortHomeBase = function(resortId, resortName, event) {
            if (event) {
                event.stopPropagation();
                event.preventDefault();
            }
            
            // Navigate to resort detail page
            window.location.href = `resort-detail.html?id=${resortId}`;
        };
    </script>
    
    <!-- Convert mapData restaurants to skiEatsData format -->
    <script>
        // Helper function to normalize category - handles both string and array
        function normalizeCategory(category, fallback = 'restaurant') {
            if (!category) return [fallback];
            if (Array.isArray(category)) {
                return category.map(c => String(c).toLowerCase());
            }
            return [String(category).toLowerCase()];
        }
        
        // Helper function to get the primary category (first in array, or single value)
        function getPrimaryCategory(restaurant, fallback = 'restaurant') {
            const category = restaurant.category || restaurant.type;
            const categories = normalizeCategory(category, fallback);
            return categories[0];
        }
        
        // Helper function to check if a restaurant has a specific category
        function hasCategory(restaurant, categoryToCheck) {
            const category = restaurant.category || restaurant.type;
            const categories = normalizeCategory(category);
            const checkCategory = String(categoryToCheck).toLowerCase();
            return categories.includes(checkCategory);
        }
        
        // Helper function to convert mapData restaurants to skiEatsData format
        function convertMapDataToSkiEatsData() {
            if (typeof mapData === 'undefined' || !mapData.restaurants) {
                return;
            }
            
            // Only convert if skiEatsData.restaurants is empty
            if (typeof skiEatsData === 'undefined' || !skiEatsData.restaurants || skiEatsData.restaurants.length === 0) {
                // Resort name mapping based on location
                const resortMapping = {
                    'Whistler': 'whistler-blackcomb',
                    'Vail': 'vail',
                    'Aspen': 'aspen-snowmass',
                    'Park City': 'park-city',
                    'Jackson Hole': 'jackson-hole',
                    'Mammoth': 'mammoth-mountain',
                    'Deer Valley': 'deer-valley',
                    'Breckenridge': 'breckenridge',
                    'Telluride': 'telluride',
                    'Beaver Creek': 'beaver-creek',
                    'Steamboat': 'steamboat',
                    'Keystone': 'keystone',
                    'Heavenly': 'heavenly',
                    'Northstar': 'northstar',
                    'Palisades': 'palisades-tahoe',
                    'Snowbird': 'snowbird',
                    'Big Sky': 'big-sky',
                    'Sun Valley': 'sun-valley',
                    'Stowe': 'stowe',
                    'Killington': 'killington',
                    'Okemo': 'okemo',
                    'Mount Snow': 'mount-snow',
                    'Lake Louise': 'lake-louise',
                    'Mont Tremblant': 'mont-tremblant',
                    'Solitude': 'solitude',
                    'Alta': 'alta',
                    'Taos': 'taos-ski-valley'
                };
                
                function findResortId(location) {
                    for (const [key, id] of Object.entries(resortMapping)) {
                        if (location.includes(key)) {
                            return id;
                        }
                    }
                    return null;
                }
                
                skiEatsData.restaurants = mapData.restaurants.map(restaurant => {
                    const id = restaurant.name.toLowerCase()
                        .replace(/[^a-z0-9\s]+/g, '')
                        .replace(/\s+/g, '-')
                        .replace(/-+/g, '-')
                        .replace(/^-|-$/g, '');
                    
                    const resortId = findResortId(restaurant.location);
                    
                    return {
                        id: id,
                        name: restaurant.name,
                        location: restaurant.location,
                        coordinates: {
                            lat: restaurant.lat,
                            lng: restaurant.lng
                        },
                        category: restaurant.category || 'restaurant',
                        rating: 4.0 + (Math.random() * 1.0), // Random rating between 4.0-5.0
                        featured: Math.random() > 0.7, // 30% chance of being featured
                        resort: resortId
                    };
                });
                
                console.log(`Converted ${skiEatsData.restaurants.length} restaurants from mapData to skiEatsData`);
            }
        }
        
        // Run conversion after data.js loads
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                setTimeout(convertMapDataToSkiEatsData, 100);
            });
        } else {
            setTimeout(convertMapDataToSkiEatsData, 100);
        }
    </script>
    
    <!-- Smooth Scroll and Interactions -->
    <script>
        // Enhanced error handling utility
        function handleError(error, context) {
            console.error(`Error in ${context}:`, error);
            
            let errorMessage = 'Sorry, something went wrong. Please try again.';
            let actionableMessage = '';
            
            // Provide specific error messages based on context
            if (context === 'getUserLocation') {
                if (error.code === error.PERMISSION_DENIED) {
                    errorMessage = 'Location access denied';
                    actionableMessage = 'Please enable location permissions in your browser settings to find nearby restaurants.';
                } else if (error.code === error.POSITION_UNAVAILABLE) {
                    errorMessage = 'Location unavailable';
                    actionableMessage = 'We couldn\'t determine your location. Please try again or search manually.';
                } else if (error.code === error.TIMEOUT) {
                    errorMessage = 'Location request timed out';
                    actionableMessage = 'The location request took too long. Please try again.';
                } else {
                    errorMessage = 'Unable to get your location';
                    actionableMessage = 'Please check your browser settings or try searching manually.';
                }
            } else if (context === 'renderResortCards') {
                errorMessage = 'Unable to load resorts';
                actionableMessage = 'Please refresh the page or try again later.';
            } else if (context === 'renderRestaurantCards') {
                errorMessage = 'Unable to load restaurants';
                actionableMessage = 'Please refresh the page or try again later.';
            } else if (context === 'initMap') {
                errorMessage = 'Map failed to load';
                actionableMessage = 'Please check your internet connection and refresh the page.';
            } else if (context === 'loadData') {
                errorMessage = 'Data failed to load';
                actionableMessage = 'Please check your internet connection and refresh the page.';
            }
            
            showErrorMessage(errorMessage, actionableMessage);
        }
        
        // Show error message toast
        function showErrorMessage(title, message = '') {
            const errorMsg = document.getElementById('errorMessage');
            const errorText = document.getElementById('errorText');
            if (errorMsg && errorText) {
                errorText.innerHTML = message ? `<strong>${title}</strong><br><span class="text-xs mt-1 block">${message}</span>` : title;
                errorMsg.classList.remove('hidden');
                
                // Auto-hide after 7 seconds
                setTimeout(() => {
                    errorMsg.classList.add('hidden');
                }, 7000);
            }
        }
        
        // Show success message toast
        function showSuccessMessage(message) {
            const successMsg = document.getElementById('successMessage');
            const successText = document.getElementById('successText');
            if (successMsg && successText) {
                successText.textContent = message;
                successMsg.classList.remove('hidden');
                
                // Auto-hide after 4 seconds
                setTimeout(() => {
                    successMsg.classList.add('hidden');
                }, 4000);
            }
        }
        
        // Show empty state message
        function showEmptyState(containerId, message, icon = null) {
            const container = document.getElementById(containerId);
            if (!container) return;
            
            const emptyStateHTML = `
                <div class="text-center py-12 px-6">
                    ${icon || '<svg class="w-16 h-16 mx-auto text-gray-400 mb-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.172 16.172a4 4 0 015.656 0M9 10h.01M15 10h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>'}
                    <h3 class="text-lg font-semibold text-gray-900 mb-2">${message.title || 'No results found'}</h3>
                    <p class="text-gray-600 mb-4">${message.description || 'Try adjusting your filters or search terms.'}</p>
                    ${message.action ? `<button onclick="${message.action}" class="px-4 py-2 bg-[var(--accent-blue)] text-white rounded-full text-sm font-medium hover:opacity-90 transition-opacity">${message.actionText || 'Clear Filters'}</button>` : ''}
                </div>
            `;
            
            container.innerHTML = emptyStateHTML;
        }
        
        // Logo API service with caching
        const logoCache = new Map();
        
        // Resort domain mapping for logo fetching
        const resortDomains = {
            'whistler-blackcomb': 'whistlerblackcomb.com',
            'vail': 'vail.com',
            'park-city': 'parkcitymountain.com',
            'mont-tremblant': 'tremblant.ca',
            'aspen-snowmass': 'aspensnowmass.com',
            'breckenridge': 'breckenridge.com',
            'steamboat': 'steamboat.com',
            'telluride': 'tellurideskiresort.com',
            'beaver-creek': 'beavercreek.com',
            'keystone': 'keystoneresort.com',
            'copper-mountain': 'coppercolorado.com',
            'winter-park': 'winterparkresort.com',
            'arapahoe-basin': 'arapahoebasin.com',
            'jackson-hole': 'jacksonhole.com',
            'big-sky': 'bigskyresort.com',
            'stowe': 'stowe.com',
            'mammoth-mountain': 'mammothmountain.com',
            'deer-valley': 'deervalley.com',
            'alta': 'alta.com',
            'snowbird': 'snowbird.com',
            'solitude': 'solitudemountain.com',
            'brighton': 'brightonresort.com',
            'sundance': 'sundanceresort.com',
            'palisades-tahoe': 'palisadestahoe.com',
            'northstar': 'northstarcalifornia.com',
            'kirkwood': 'kirkwood.com',
            'killington': 'killington.com',
            'sugarbush': 'sugarbush.com',
            'mount-snow': 'mountsnow.com',
            'sun-valley': 'sunvalley.com',
            'crested-butte': 'skicb.com',
            'jay-peak': 'jaypeakresort.com',
            'snowshoe': 'snowshoemtn.com',
            'taos': 'skitaos.com',
            'smugglers-notch': 'smuggs.com',
            'wisp-resort': 'wispresort.com'
        };
        
        /**
         * Fetch logo from multiple API services with fallback
         * @param {string} resortId - The resort ID
         * @param {string} resortName - The resort name
         * @returns {Promise<string|null>} - Logo URL or null
         */
        async function fetchResortLogo(resortId, resortName) {
            // Check cache first
            if (logoCache.has(resortId)) {
                return logoCache.get(resortId);
            }
            
            const domain = resortDomains[resortId];
            if (!domain) {
                console.warn(`No domain mapping for resort: ${resortId}`);
                logoCache.set(resortId, null);
                return null;
            }
            
            // Try multiple logo API services
            const logoApis = [
                // Google's favicon service (most reliable, no CORS issues)
                {
                    url: `https://www.google.com/s2/favicons?domain=${domain}&sz=128`,
                    type: 'image'
                },
                // iFetchly Logo API (free tier: 5,000 requests/month)
                {
                    url: `https://logo.ifetchly.com/api/${domain}?size=256&format=png`,
                    type: 'json'
                },
                // Direct favicon fetch (may have CORS issues, but try anyway)
                {
                    url: `https://${domain}/favicon.ico`,
                    type: 'image'
                }
            ];
            
            // Try each API in sequence
            for (const api of logoApis) {
                try {
                    // For direct image URLs, use img tag approach to avoid CORS
                    if (api.type === 'image' && api.url.includes('google.com')) {
                        // Google's service works well, just return the URL
                        logoCache.set(resortId, api.url);
                        return api.url;
                    }
                    
                    // For other APIs, try fetch
                    const response = await fetch(api.url, {
                        method: 'GET',
                        mode: 'cors',
                        cache: 'default',
                        headers: {
                            'Accept': api.type === 'json' ? 'application/json' : 'image/*'
                        }
                    });
                    
                    if (response.ok) {
                        if (api.type === 'json') {
                            try {
                                const data = await response.json();
                                if (data.logo || data.url) {
                                    const logoUrl = data.logo || data.url;
                                    logoCache.set(resortId, logoUrl);
                                    return logoUrl;
                                }
                            } catch (e) {
                                // Not JSON, continue
                            }
                        } else {
                            // For image responses, check content type
                            const contentType = response.headers.get('content-type');
                            if (contentType && contentType.startsWith('image/')) {
                                logoCache.set(resortId, api.url);
                                return api.url;
                            }
                        }
                    }
                } catch (error) {
                    // Continue to next API
                    console.debug(`Logo API failed for ${domain}:`, api.url);
                }
            }
            
            // All APIs failed, cache null
            logoCache.set(resortId, null);
            return null;
        }
        
        // Global function to toggle favorites (used by resort card component)
        window.toggleResortFavorite = function(resortId, resortName, event) {
            if (event) {
                event.stopPropagation();
                event.preventDefault();
            }
            
            try {
                const favorites = JSON.parse(localStorage.getItem('snogrub_favorites') || '[]');
                const existingIndex = favorites.findIndex(fav => fav.id === resortId && fav.type === 'resort');
                
                let isFavorited = false;
                if (existingIndex >= 0) {
                    // Remove from favorites
                    favorites.splice(existingIndex, 1);
                    isFavorited = false;
                } else {
                    // Add to favorites
                    favorites.push({
                        id: resortId,
                        type: 'resort',
                        name: resortName,
                        addedAt: new Date().toISOString()
                    });
                    isFavorited = true;
                }
                localStorage.setItem('snogrub_favorites', JSON.stringify(favorites));
                
                // Update button
                const button = event?.target?.closest('.favorite-button');
                if (button) {
                    button.setAttribute('aria-checked', isFavorited ? 'true' : 'false');
                    if (isFavorited) {
                        button.classList.add('favorited');
                    } else {
                        button.classList.remove('favorited');
                    }
                    const icon = button.querySelector('svg');
                    if (icon) {
                        if (isFavorited) {
                            icon.classList.add('fill-red-500', 'text-red-500');
                            icon.classList.remove('fill-none', 'text-gray-400');
                            icon.setAttribute('fill', 'currentColor');
                        } else {
                            icon.classList.remove('fill-red-500', 'text-red-500');
                            icon.classList.add('fill-none', 'text-gray-400');
                            icon.setAttribute('fill', 'none');
                        }
                    }
                }
                
                // Dispatch custom event for other components to listen
                window.dispatchEvent(new CustomEvent('favoritesChanged', {
                    detail: { resortId, favorited: isFavorited }
                }));
            } catch (e) {
                console.error('Error toggling favorite:', e);
            }
        };
        
        // Initialize Universal Resort Card component for index page
        let indexResortCard;
        if (typeof UniversalResortCard !== 'undefined') {
            indexResortCard = new UniversalResortCard({
                showLogo: true,
                showTrailMap: true,
                showStats: true,
                showRating: true,
                showPriceRating: true,
                showFeaturedBadge: true,
                showDistance: true,
                showQuickView: false, // Disable on homepage
                showHoverOverlay: true,
                imageHeight: 'h-48',
                cardVariant: 'default',
                showInlineLogo: false,
                clickable: true,
                hoverEffect: true,
                animation: true
            });
        }
        
        // Helper function to render a single resort card (using UniversalResortCard if available)
        function renderResortCard(resort, index) {
            // Use UniversalResortCard if available
            if (indexResortCard && typeof indexResortCard.render === 'function') {
                return indexResortCard.render(resort, index);
            }
            
            // Fallback to old rendering (deprecated - should use UniversalResortCard)
            return renderResortCardOld(resort, index);
        }
        
        // Old rendering function (kept as fallback)
        function renderResortCardOld(resort, index) {
            // Color gradients for resort cards
            const resortColors = [
                { bg: 'from-blue-100 to-blue-50', icon: 'text-blue-400', text: 'text-blue-600' },
                { bg: 'from-gray-100 to-gray-50', icon: 'text-gray-500', text: 'text-gray-600' },
                { bg: 'from-blue-50 to-white', icon: 'text-blue-400', text: 'text-blue-500' },
                { bg: 'from-blue-100 to-blue-200', icon: 'text-blue-600', text: 'text-blue-700' }
            ];
            
            // Mountain icon variations
            const mountainIcons = [
                { path: 'M10 70 L30 30 L50 50 L70 20 L90 60 L100 50 L100 100 L10 100 Z', snow: 'M30 30 L50 50 L70 20 L50 35 Z' },
                { path: 'M5 75 L25 25 L45 45 L65 15 L85 55 L95 45 L95 100 L5 100 Z', snow: 'M25 25 L45 45 L65 15 L45 30 Z' },
                { path: 'M8 72 L28 28 L48 48 L68 18 L88 58 L98 48 L98 100 L8 100 Z', snow: 'M28 28 L48 48 L68 18 L48 33 Z' },
                { path: 'M12 68 L32 24 L52 44 L72 14 L92 54 L100 44 L100 100 L12 100 Z', snow: 'M32 24 L52 44 L72 14 L52 29 Z' }
            ];
            
            const colors = resortColors[index % resortColors.length];
            const icon = mountainIcons[index % mountainIcons.length];
            
            // Generate satellite map image using Google Maps Static API
            // Note: This requires a Google Maps API key. For production, add your key.
            // Free tier: $200 credit/month (28,000 map loads)
            // To get a Google Maps API key: https://console.cloud.google.com/google/maps-apis
            // Alternative: Use Esri World Imagery tiles (free, no API key) - currently in use
            const googleMapsApiKey = ''; // Add your Google Maps API key here for better quality satellite images
            
            let satelliteImageUrl;
            if (googleMapsApiKey) {
                // Google Maps Static API (best quality, requires API key)
                satelliteImageUrl = `https://maps.googleapis.com/maps/api/staticmap?center=${resort.coordinates.lat},${resort.coordinates.lng}&zoom=12&size=400x300&maptype=satellite&key=${googleMapsApiKey}`;
            } else {
                // Esri World Imagery (free, no API key required)
                // Calculate tile coordinates
                const zoom = 12;
                const scale = Math.pow(2, zoom);
                const worldCoordinateX = (resort.coordinates.lng + 180) / 360 * scale;
                const worldCoordinateY = (1 - Math.log(Math.tan(resort.coordinates.lat * Math.PI / 180) + 1 / Math.cos(resort.coordinates.lat * Math.PI / 180)) / Math.PI) / 2 * scale;
                const tileX = Math.floor(worldCoordinateX);
                const tileY = Math.floor(worldCoordinateY);
                
                // Use Esri World Imagery tile service
                satelliteImageUrl = `https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/${zoom}/${tileY}/${tileX}`;
            }
            
            // Fallback gradient if image fails to load
            const fallbackGradient = `bg-gradient-to-br ${colors.bg}`;
            
            return `
                <div class="group bg-white border border-gray-200 rounded-lg overflow-hidden hover:shadow-xl transition-all duration-300">
                    <div class="aspect-[4/3] relative overflow-hidden ${fallbackGradient}">
                        <a href="resort-detail.html?id=${resort.id}" 
                           class="block w-full h-full">
                            <!-- Satellite Map Image -->
                            <img src="${satelliteImageUrl}" 
                                 alt="${resort.name} satellite view"
                                 class="w-full h-full object-cover group-hover:scale-105 transition-transform duration-500 cursor-pointer"
                                 onerror="this.onerror=null; this.style.display='none'; this.parentElement.parentElement.classList.add('${fallbackGradient}');"
                                 loading="lazy">
                            
                            <!-- Gradient Overlay for better text readability -->
                            <div class="absolute inset-0 bg-gradient-to-t from-black/60 via-black/20 to-transparent pointer-events-none"></div>
                            
                            <!-- Resort Name Overlay -->
                            <div class="absolute bottom-0 left-0 right-0 p-4 pointer-events-none">
                                <h3 class="text-white font-semibold text-lg drop-shadow-lg">${resort.name}</h3>
                                <p class="text-white/90 text-sm drop-shadow">${resort.location}</p>
                            </div>
                            
                            <!-- Resort Logo -->
                            <div class="absolute top-3 left-3 right-3 flex justify-center pointer-events-none" data-resort-logo-overlay="${resort.id}">
                                <div class="bg-white/95 backdrop-blur-sm rounded-lg p-3 shadow-xl max-w-[180px] logo-container">
                                    <div class="resort-logo-loading" style="display: flex; align-items: center; justify-content: center; min-height: 48px;">
                                        <svg class="animate-spin h-5 w-5 text-gray-400" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                                            <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                                            <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                                        </svg>
                                    </div>
                                    <img src="" 
                                         alt="${resort.name} logo"
                                         class="w-full h-auto max-h-12 object-contain resort-logo-img"
                                         style="display: none;"
                                         onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';"
                                         loading="lazy">
                                    <div class="resort-logo-fallback" style="display: none; align-items: center; justify-content: center; min-height: 48px; padding: 4px;">
                                        <span class="text-xs font-bold text-gray-800 text-center leading-tight">${resort.name}</span>
                                    </div>
                                </div>
                            </div>
                        </a>
                    </div>
                    <div class="p-6">
                        <!-- Logo in card content (for better visibility) -->
                        <div class="mb-3 flex justify-center items-center logo-container-inline" data-resort-logo-inline="${resort.id}">
                            <div class="resort-logo-loading-inline" style="display: flex; align-items: center; justify-center; min-height: 32px;">
                                <svg class="animate-spin h-4 w-4 text-gray-400" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                                    <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                                    <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                                </svg>
                            </div>
                            <img src="" 
                                 alt="${resort.name} logo"
                                 class="h-8 w-auto object-contain resort-logo-img-inline"
                                 style="display: none;"
                                 onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';"
                                 loading="lazy">
                            <div class="resort-logo-fallback-inline" style="display: none; align-items: center; justify-content: center; min-height: 32px; padding: 4px 8px; background: linear-gradient(135deg, ${colors.gradientStart || '#3b82f6'} 0%, ${colors.gradientEnd || '#1d4ed8'} 100%); border-radius: 6px;">
                                <span class="text-sm font-bold text-white text-center">${resort.name}</span>
                            </div>
                        </div>
                        <h3 class="text-xl font-semibold text-gray-900 mb-2 group-hover:text-[var(--accent-blue)] transition-colors duration-200">
                            ${resort.name}
                        </h3>
                        <p class="text-gray-600 text-sm mb-3">
                            ${resort.location}
                        </p>
                        
                        <!-- Resort Information Stats -->
                        <div class="mb-4 space-y-2">
                            ${resort.distance ? `
                            <div class="flex items-center text-sm text-gray-700">
                                <svg class="w-4 h-4 mr-2 text-gray-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17.657 16.657L13.414 20.9a1.998 1.998 0 01-2.827 0l-4.244-4.243a8 8 0 1111.314 0z"></path>
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 11a3 3 0 11-6 0 3 3 0 016 0z"></path>
                                </svg>
                                <span class="font-medium">${resort.distance.toFixed(1)} mi away</span>
                            </div>
                            ` : ''}
                            
                            ${resort.restaurantCount ? `
                            <div class="flex items-center text-sm text-gray-700">
                                <svg class="w-4 h-4 mr-2 text-gray-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 12l2-2m0 0l7-7 7 7M5 10v10a1 1 0 001 1h3m10-11l2 2m-2-2v10a1 1 0 01-1 1h-3m-6 0a1 1 0 001-1v-4a1 1 0 011-1h2a1 1 0 011 1v4a1 1 0 001 1m-6 0h6"></path>
                                </svg>
                                <span><span class="font-medium">${resort.restaurantCount}</span> restaurants</span>
                            </div>
                            ` : ''}
                            
                            ${resort.trails && resort.trails.total ? `
                            <div class="flex items-center text-sm text-gray-700">
                                <svg class="w-4 h-4 mr-2 text-gray-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 20l-5.447-2.724A1 1 0 013 16.382V5.618a1 1 0 011.447-.894L9 7m0 13l6-3m-6 3V7m6 10l4.553 2.276A1 1 0 0021 18.382V7.618a1 1 0 00-.553-.894L15 4m0 13V4m0 0L9 7"></path>
                                </svg>
                                <span><span class="font-medium">${resort.trails.total}</span> trails</span>
                            </div>
                            ` : ''}
                            
                            ${resort.terrain && resort.terrain.verticalDrop ? `
                            <div class="flex items-center text-sm text-gray-700">
                                <svg class="w-4 h-4 mr-2 text-gray-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 7h8m0 0v8m0-8l-8 8-4-4-6 6"></path>
                                </svg>
                                <span><span class="font-medium">${resort.terrain.verticalDrop.toLocaleString()}</span> ft vertical drop</span>
                            </div>
                            ` : ''}
                            
                            ${resort.lifts && resort.lifts.total ? `
                            <div class="flex items-center text-sm text-gray-700">
                                <svg class="w-4 h-4 mr-2 text-gray-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z"></path>
                                </svg>
                                <span><span class="font-medium">${resort.lifts.total}</span> lifts</span>
                            </div>
                            ` : ''}
                        </div>
                        
                        <a href="resort-detail.html?id=${resort.id}" 
                           class="inline-flex items-center justify-center px-5 py-2.5 bg-[var(--accent-blue)] text-white rounded-full text-sm font-medium hover:opacity-90 transition-opacity duration-200 shadow-sm hover:shadow-md"
                           onclick="event.stopPropagation()">
                            View Resort
                            <svg class="w-4 h-4 ml-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path>
                            </svg>
                        </a>
                    </div>
                </div>
            `;
        }
        
        // Load and render featured and closest resorts
        function renderResortCards() {
            try {
                const featuredResortGrid = document.getElementById('featuredResortGrid');
                const closestResortGrid = document.getElementById('closestResortGrid');
                
                if (!featuredResortGrid || !closestResortGrid || typeof skiEatsData === 'undefined' || !skiEatsData.resorts) {
                    console.warn('Resort data not available');
                    if (featuredResortGrid) {
                        showEmptyState('featuredResortGrid', {
                            title: 'Data Not Available',
                            description: 'Unable to load resort data. Please check your internet connection and refresh the page.',
                            action: 'window.location.reload()',
                            actionText: 'Refresh Page'
                        });
                    }
                    if (closestResortGrid) {
                        showEmptyState('closestResortGrid', {
                            title: 'Data Not Available',
                            description: 'Unable to load resort data. Please check your internet connection and refresh the page.',
                            action: 'window.location.reload()',
                            actionText: 'Refresh Page'
                        });
                    }
                    handleError(new Error('Resort data not available'), 'loadData');
                    return;
                }
                
                // Clear skeleton loaders
                featuredResortGrid.innerHTML = '';
                closestResortGrid.innerHTML = '';
            
                // Check if we have data
                if (!skiEatsData.resorts || skiEatsData.resorts.length === 0) {
                    showEmptyState('featuredResortGrid', {
                        title: 'No Resorts Available',
                        description: 'We couldn\'t find any resorts to display. Please try again later.',
                        action: null
                    });
                    showEmptyState('closestResortGrid', {
                        title: 'No Resorts Available',
                        description: 'We couldn\'t find any resorts to display. Please try again later.',
                        action: null
                    });
                    return;
                }
                
                // Check if user location is stored in localStorage
                const storedLocation = localStorage.getItem('snogrub_user_location');
                let userLat = null;
                let userLng = null;
                
                if (storedLocation) {
                    try {
                        const location = JSON.parse(storedLocation);
                        userLat = location.lat;
                        userLng = location.lng;
                    } catch (e) {
                        console.error('Error parsing stored location:', e);
                    }
                }
                
                // Helper function to calculate restaurant count for a resort
                function calculateRestaurantCount(resortId) {
                    if (!skiEatsData.restaurants || skiEatsData.restaurants.length === 0) {
                        return 0;
                    }
                    return skiEatsData.restaurants.filter(r => r.resort === resortId).length;
                }
                
                // Helper function to enrich resort data with calculated values
                function enrichResortData(resort) {
                    const enriched = { ...resort };
                    
                    // Calculate restaurant count if not available
                    if (!enriched.restaurantCount && skiEatsData.restaurants) {
                        enriched.restaurantCount = calculateRestaurantCount(resort.id);
                    }
                    
                    // Calculate distance if user location is available
                    if (userLat && userLng && !enriched.distance) {
                        const distanceKm = calculateDistance(
                            userLat,
                            userLng,
                            resort.coordinates.lat,
                            resort.coordinates.lng
                        );
                        enriched.distance = distanceKm * 0.621371; // Convert km to miles
                    }
                    
                    return enriched;
                }
                
                // Check if home base is active
                const homeBaseActive = typeof HomeBase !== 'undefined' && HomeBase.isActive();
                const homeBaseResort = homeBaseActive ? HomeBase.getHomeBaseResort() : null;
                const homeBaseName = homeBaseActive ? HomeBase.getResortName() : null;
                
                // Update section titles based on home base
                const featuredResortTitle = document.getElementById('featuredResortTitle');
                const closestResortTitle = document.getElementById('closestResortTitle');
                
                if (homeBaseActive && homeBaseName) {
                    if (featuredResortTitle) {
                        featuredResortTitle.textContent = 'Home Base';
                    }
                    if (closestResortTitle) {
                        closestResortTitle.textContent = `Resorts Near ${homeBaseName}`;
                    }
                } else {
                    if (featuredResortTitle) {
                        featuredResortTitle.textContent = 'Featured Resort';
                    }
                    if (closestResortTitle) {
                        closestResortTitle.textContent = 'Closest Resort';
                    }
                }
                
                let allResorts = [...skiEatsData.resorts];
                let featuredResorts = [];
                let closestResorts = [];
                
                if (homeBaseActive && homeBaseResort) {
                    // Home base is active - show home base as featured
                    featuredResorts = [homeBaseResort];
                    
                    // Get closest resorts to home base (excluding home base itself)
                    const homeBaseLat = homeBaseResort.coordinates?.lat;
                    const homeBaseLng = homeBaseResort.coordinates?.lng;
                    
                    if (homeBaseLat && homeBaseLng) {
                        closestResorts = allResorts
                            .filter(r => r.id !== homeBaseResort.id && r.coordinates)
                            .map(resort => {
                                const distanceKm = calculateDistance(
                                    homeBaseLat,
                                    homeBaseLng,
                                    resort.coordinates.lat,
                                    resort.coordinates.lng
                                );
                                const distanceMiles = distanceKm * 0.621371; // Convert km to miles
                                return { ...resort, distance: distanceMiles };
                            })
                            .sort((a, b) => a.distance - b.distance)
                            .slice(0, 1);
                    } else {
                        // No coordinates for home base, show popular resorts
                        closestResorts = allResorts
                            .filter(r => r.id !== homeBaseResort.id)
                            .sort((a, b) => {
                                const aCount = a.restaurantCount || calculateRestaurantCount(a.id);
                                const bCount = b.restaurantCount || calculateRestaurantCount(b.id);
                                return bCount - aCount;
                            })
                            .slice(0, 1);
                    }
                } else {
                    // No home base - use original logic
                    // Get featured resort (show 1) - randomly select a different resort each time
                    const randomIndex = allResorts.length > 0 ? Math.floor(Math.random() * allResorts.length) : 0;
                    featuredResorts = allResorts.length > 0 ? [allResorts[randomIndex]] : [];
                    
                    // Get closest resort (1 resort)
                    if (userLat && userLng) {
                        // User location available - show 1 closest resort
                        closestResorts = allResorts
                            .filter(r => !featuredResorts.some(fr => fr.id === r.id))
                            .map(resort => {
                                const distanceKm = calculateDistance(
                                    userLat, 
                                    userLng, 
                                    resort.coordinates.lat, 
                                    resort.coordinates.lng
                                );
                                const distanceMiles = distanceKm * 0.621371; // Convert km to miles
                                return { ...resort, distance: distanceMiles };
                            })
                            .sort((a, b) => a.distance - b.distance)
                            .slice(0, 1);
                    } else {
                        // No user location - show 1 additional featured or popular resort
                        const nonFeaturedResorts = allResorts
                            .filter(r => !featuredResorts.some(fr => fr.id === r.id))
                            .sort((a, b) => {
                                const aCount = a.restaurantCount || calculateRestaurantCount(a.id);
                                const bCount = b.restaurantCount || calculateRestaurantCount(b.id);
                                return bCount - aCount;
                            })
                            .slice(0, 1);
                        closestResorts = nonFeaturedResorts;
                    }
                }
                
                // Enrich featured resort data
                featuredResorts = featuredResorts.map(enrichResortData);
                
                // Render featured resort
                featuredResortGrid.innerHTML = featuredResorts.map((resort, index) => {
                    return renderResortCard(resort, index);
                }).join('');
                
                // Enrich closest resort data
                closestResorts = closestResorts.map(enrichResortData);
                
                // Render closest resort
                closestResortGrid.innerHTML = closestResorts.map((resort, index) => {
                    return renderResortCard(resort, index + 1);
                }).join('');
                
                // Load logos for all rendered resorts
                if (typeof loadResortLogos === 'function') {
                    loadResortLogos([...featuredResorts, ...closestResorts]);
                }
                
                // Initialize price ratings if available
                if (typeof initializePriceRatings === 'function') {
                    initializePriceRatings();
                }
                
            } catch (error) {
                handleError(error, 'renderResortCards');
            }
        }
        
        /**
         * Load logos for resorts and update the DOM (updated to hide containers when no logo)
         * @param {Array} resorts - Array of resort objects
         */
        async function loadResortLogos(resorts) {
            const logoPromises = resorts.map(async (resort) => {
                try {
                    const logoUrl = await fetchResortLogo(resort.id, resort.name);
                    
                    // Update overlay logo container
                    const overlayContainer = document.querySelector(`.resort-logo-overlay-container[data-resort-logo-overlay="${resort.id}"]`);
                    if (overlayContainer) {
                        if (logoUrl) {
                            const img = overlayContainer.querySelector('.resort-logo-img');
                            const loading = overlayContainer.querySelector('.resort-logo-loading');
                            if (img && loading) {
                                // Set up image loading
                                img.onload = function() {
                                    const container = this.closest('.resort-logo-overlay-container');
                                    if (container) {
                                        container.style.display = 'flex';
                                        this.style.display = 'block';
                                    }
                                    if (loading) loading.style.display = 'none';
                                };
                                img.onerror = function() {
                                    const container = this.closest('.resort-logo-overlay-container');
                                    if (container) container.style.display = 'none';
                                };
                                img.src = logoUrl;
                                // Show container with loading state
                                overlayContainer.style.display = 'flex';
                            }
                        } else {
                            // No logo found, hide the container completely
                            overlayContainer.style.display = 'none';
                        }
                    }
                } catch (error) {
                    console.warn(`Failed to load logo for ${resort.name}:`, error);
                    // Hide containers on error
                    const overlayContainer = document.querySelector(`.resort-logo-overlay-container[data-resort-logo-overlay="${resort.id}"]`);
                    if (overlayContainer) {
                        overlayContainer.style.display = 'none';
                    }
                }
            });
            
            // Wait for all logos to load (or fail)
            await Promise.allSettled(logoPromises);
        }
        
        // Global variables to track restaurant state
        let sortedRestaurants = [];
        let displayedRestaurantCount = 0;
        const INITIAL_RESTAURANT_COUNT = 3;
        const LOAD_MORE_COUNT = 4;
        
        // Helper function to generate satellite image URL
        function getSatelliteImageUrl(lat, lng, width = 640, height = 360) {
            const zoom = 17;
            const scale = Math.pow(2, zoom);
            const worldCoordinateX = (lng + 180) / 360 * scale;
            const worldCoordinateY = (1 - Math.log(Math.tan(lat * Math.PI / 180) + 1 / Math.cos(lat * Math.PI / 180)) / Math.PI) / 2 * scale;
            const tileX = Math.floor(worldCoordinateX);
            const tileY = Math.floor(worldCoordinateY);
            return `https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/${zoom}/${tileY}/${tileX}`;
        }
        
        // Helper functions for enhanced card features
        function getReviewSnippet(restaurant) {
            if (restaurant.platformReviews) {
                const reviews = Object.values(restaurant.platformReviews);
                if (reviews.length > 0 && reviews[0].positive) {
                    return reviews[0].positive.substring(0, 120) + '...';
                }
            }
            return null;
        }
        
        function getSocialProof(restaurant) {
            const proof = [];
            if (restaurant.reviewCount && restaurant.reviewCount > 100) {
                proof.push(`${restaurant.reviewCount}+ reviews`);
            }
            if (restaurant.featured) {
                proof.push('Featured');
            }
            return proof;
        }
        
        function getQuickActions(restaurant) {
            const actions = [];
            if (restaurant.phone) {
                actions.push({
                    label: 'Call',
                    icon: 'phone',
                    action: `tel:${restaurant.phone}`
                });
            }
            if (restaurant.coordinates) {
                actions.push({
                    label: 'Directions',
                    icon: 'map',
                    action: `https://www.google.com/maps?q=${restaurant.coordinates.lat},${restaurant.coordinates.lng}`
                });
            }
            if (restaurant.website) {
                actions.push({
                    label: 'Reserve',
                    icon: 'calendar',
                    action: restaurant.website
                });
            }
            return actions;
        }
        
        function getAvailabilityStatus(restaurant) {
            if (!restaurant.hours) return null;
            const now = new Date();
            const day = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'][now.getDay()];
            const hours = restaurant.hours[day];
            if (!hours || hours === 'Closed') return { status: 'closed', label: 'Closed' };
            return { status: 'open', label: 'Open Now' };
        }
        
        function getPhotoCount(restaurant) {
            // Placeholder - would require photo data
            return null;
        }
        
        function getLastUpdated(restaurant) {
            // Placeholder - would require update timestamp
            return null;
        }
        
        function shareRestaurant(restaurantId) {
            const restaurant = skiEatsData.restaurants?.find(r => r.id === restaurantId);
            const url = `${window.location.origin}/restaurant-detail.html?id=${restaurantId}`;
            const title = restaurant ? `${restaurant.name} - SNOGRUB` : 'Restaurant - SNOGRUB';
            
            if (navigator.share) {
                navigator.share({ 
                    title: title,
                    text: restaurant ? `Check out ${restaurant.name}` : '',
                    url: url 
                });
            } else {
                navigator.clipboard.writeText(url);
                alert('Link copied to clipboard!');
            }
        }
        
        function showQuickPreview(restaurantId) {
            const restaurant = normalizedRestaurants.find(r => r.id === restaurantId) || 
                             skiEatsData.restaurants?.find(r => r.id === restaurantId);
            if (!restaurant) return;
            
            // Normalize if needed
            const normalized = normalizeRestaurantResorts(restaurant, skiEatsData.resorts || []);
            
            const modal = document.getElementById('previewModal');
            const content = document.getElementById('previewContent');
            
            if (!modal || !content) return;
            
            // Format resort display
            const restaurantResorts = getRestaurantResorts(normalized);
            let resortDisplay = '';
            if (restaurantResorts.length === 0) {
                resortDisplay = `<p class="text-gray-600 mb-4">${normalized.location || 'Location TBD'}</p>`;
            } else if (restaurantResorts.length === 1) {
                const r = restaurantResorts[0];
                const resort = skiEatsData.resorts?.find(res => res.id === r.id);
                const name = resort ? resort.name : r.id;
                const distanceText = r.distance !== null && r.distance !== undefined ? ` (${r.distance.toFixed(1)} mi)` : '';
                resortDisplay = `<p class="text-gray-600 mb-4">${name}${distanceText}</p>`;
            } else {
                const resortLines = restaurantResorts.map(r => {
                    const resort = skiEatsData.resorts?.find(res => res.id === r.id);
                    const name = resort ? resort.name : r.id;
                    const distanceText = r.distance !== null && r.distance !== undefined ? ` (${r.distance.toFixed(1)} mi)` : '';
                    return `<div class="text-gray-600">${name}${distanceText}</div>`;
                }).join('');
                resortDisplay = `<div class="mb-4 space-y-1">${resortLines}</div>`;
            }
            
            const priceRange = normalized.priceRange || normalized.price || '';
            const cuisine = normalized.cuisine || normalized.type || '';
            const category = getPrimaryCategory(normalized, 'restaurant');
            
            content.innerHTML = `
                <button class="close-btn" onclick="document.getElementById('previewModal').classList.remove('active')">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                    </svg>
                </button>
                <div class="space-y-4">
                    <div>
                        <h2 class="text-3xl font-bold text-gray-900 mb-3">${normalized.name}</h2>
                        ${resortDisplay}
                    </div>
                    <div class="flex items-center gap-4 flex-wrap">
                        ${normalized.rating ? `
                            <div class="flex items-center gap-2">
                                <svg class="w-5 h-5 text-yellow-500 fill-current" viewBox="0 0 20 20">
                                    <path d="M10 15l-5.878 3.09 1.123-6.545L.489 6.91l6.572-.955L10 0l2.939 5.955 6.572.955-4.756 4.635 1.123 6.545z"/>
                                </svg>
                                <span class="text-lg font-bold text-gray-900">${normalized.rating.toFixed(1)}</span>
                            </div>
                        ` : ''}
                        ${priceRange ? `<span class="text-gray-700 font-medium">${priceRange}</span>` : ''}
                        ${cuisine ? `<span class="text-gray-600">${cuisine}</span>` : ''}
                    </div>
                    ${normalized.description ? `
                        <div class="pt-4 border-t border-gray-200">
                            <h3 class="text-sm font-semibold text-gray-900 uppercase tracking-wide mb-2">About</h3>
                            <p class="text-gray-700 leading-relaxed">${normalized.description}</p>
                        </div>
                    ` : ''}
                    <div class="pt-4">
                        <a href="restaurant-detail.html?id=${normalized.id}" class="inline-flex items-center gap-2 px-6 py-3 bg-[var(--accent-blue)] text-white rounded-full font-semibold hover:opacity-90 transition-opacity shadow-lg hover:shadow-xl">
                            View Full Details
                            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path>
                            </svg>
                        </a>
                    </div>
                </div>
            `;
            
            modal.classList.add('active');
            
            // Close modal when clicking outside or on close button
            const closeBtn = document.getElementById('closePreviewBtn');
            if (closeBtn) {
                closeBtn.onclick = () => modal.classList.remove('active');
            }
            modal.onclick = (e) => {
                if (e.target === modal) {
                    modal.classList.remove('active');
                }
            };
        }
        
        // Store normalized restaurants for quick preview access
        let normalizedRestaurants = [];
        
        // Get sorted restaurants list (sorted by distance if location available, otherwise by popularity)
        function getSortedRestaurants() {
            if (sortedRestaurants.length > 0) {
                return sortedRestaurants;
            }
            
            // Check if user location is stored in localStorage
            const storedLocation = localStorage.getItem('snogrub_user_location');
            let userLat = null;
            let userLng = null;
            
            if (storedLocation) {
                try {
                    const location = JSON.parse(storedLocation);
                    userLat = location.lat;
                    userLng = location.lng;
                } catch (e) {
                    console.error('Error parsing stored location:', e);
                }
            }
            
            // Normalize restaurant data first (convert old resort to new resorts array)
            normalizedRestaurants = normalizeRestaurantResorts(
                skiEatsData.restaurants,
                skiEatsData.resorts || []
            );
            
            // Check if home base is active
            const homeBaseActive = typeof HomeBase !== 'undefined' && HomeBase.isActive();
            let filteredRestaurants = normalizedRestaurants;
            
            if (homeBaseActive) {
                // When home base is active, sort by distance from home base (not filter to only home base)
                // This shows all restaurants but prioritizes those closest to home base
                filteredRestaurants = HomeBase.sortRestaurantsByDistance(normalizedRestaurants);
                sortedRestaurants = filteredRestaurants;
            } else if (userLat && userLng) {
                // User location available - sort by distance (closest first)
                sortedRestaurants = filteredRestaurants
                    .map(restaurant => {
                        const distanceKm = calculateDistance(
                            userLat, 
                            userLng, 
                            restaurant.coordinates.lat, 
                            restaurant.coordinates.lng
                        );
                        const distanceMiles = distanceKm * 0.621371; // Convert km to miles
                        return { ...restaurant, distance: distanceMiles };
                    })
                    .sort((a, b) => a.distance - b.distance);
            } else {
                // No user location - sort by popularity (featured first, then by rating)
                sortedRestaurants = filteredRestaurants
                    .map(restaurant => ({ ...restaurant, distance: null }))
                    .sort((a, b) => {
                        // First sort by featured status (featured first)
                        if (a.featured && !b.featured) return -1;
                        if (!a.featured && b.featured) return 1;
                        // Then by rating (highest first)
                        return (b.rating || 0) - (a.rating || 0);
                    });
            }
            
            return sortedRestaurants;
        }
        
        // Load and render featured restaurants
        function renderRestaurantCards(count = null) {
            try {
                const restaurantGrid = document.getElementById('restaurantGrid');
                if (!restaurantGrid || typeof skiEatsData === 'undefined' || !skiEatsData.restaurants) {
                    console.warn('Restaurant data not available');
                    showEmptyState('restaurantGrid', {
                        title: 'Data Not Available',
                        description: 'Unable to load restaurant data. Please check your internet connection and refresh the page.',
                        action: 'window.location.reload()',
                        actionText: 'Refresh Page'
                    });
                    handleError(new Error('Restaurant data not available'), 'loadData');
                    return;
                }
            
            // Clear skeleton loaders
            restaurantGrid.innerHTML = '';
            
            // Update restaurant section title and description based on home base
            const restaurantsSectionTitle = document.getElementById('restaurantsSectionTitle');
            const restaurantsSectionDescription = document.getElementById('restaurantsSectionDescription');
            
            if (typeof HomeBase !== 'undefined' && HomeBase.isActive()) {
                const homeBaseName = HomeBase.getResortName();
                if (restaurantsSectionTitle && homeBaseName) {
                    restaurantsSectionTitle.textContent = `Closest places to grab a bite near ${homeBaseName}`;
                }
                if (restaurantsSectionDescription && homeBaseName) {
                    restaurantsSectionDescription.textContent = `Discover exceptional dining experiences near ${homeBaseName} and surrounding ski resorts.`;
                }
            } else {
                if (restaurantsSectionTitle) {
                    restaurantsSectionTitle.textContent = 'Closest places to grab a bite';
                }
                if (restaurantsSectionDescription) {
                    restaurantsSectionDescription.textContent = 'Discover exceptional dining experiences at ski resorts across North America.';
                }
            }
            
            // Get sorted restaurants
            const allSortedRestaurants = getSortedRestaurants();
            
            // Check if we have restaurants
            if (!allSortedRestaurants || allSortedRestaurants.length === 0) {
                showEmptyState('restaurantGrid', {
                    title: 'No Restaurants Found',
                    description: 'We couldn\'t find any restaurants matching your criteria. Try adjusting your filters.',
                    action: 'document.querySelectorAll(\'.filter-btn\').forEach(btn => { if(btn.dataset.filter === \'all\') btn.click(); })',
                    actionText: 'Show All'
                });
                return;
            }
            
            // Determine how many to show
            const targetCount = count !== null ? count : INITIAL_RESTAURANT_COUNT;
            displayedRestaurantCount = Math.min(targetCount, allSortedRestaurants.length);
            
            // Get restaurants to display
            const restaurantsToShow = allSortedRestaurants.slice(0, displayedRestaurantCount);
            
            const categoryColors = {
                restaurant: { bg: 'from-amber-50 to-orange-50', icon: 'text-amber-400', badge: 'bg-gray-100 text-gray-700' },
                bar: { bg: 'from-blue-50 to-cyan-50', icon: 'text-blue-400', badge: 'bg-blue-100 text-blue-700' },
                cafe: { bg: 'from-green-50 to-emerald-50', icon: 'text-green-400', badge: 'bg-green-100 text-green-700' }
            };
            
            const categoryLabels = {
                restaurant: 'Restaurant',
                bar: 'Après Bar',
                cafe: 'Café'
            };
            
            // Function to get icon SVG based on category
            function getCategoryIcon(category) {
                switch(category) {
                    case 'restaurant':
                        // Fork and knife icon (dining utensils)
                        return `<svg class="w-20 h-20" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M12 2v20M9 2l3-1 3 1M9 2v20M15 2v20M7 4h2M7 8h2M7 12h2M7 16h2M15 4h2M15 8h2M15 12h2M15 16h2"></path>
                                </svg>`;
                    case 'bar':
                        // Martini glass icon
                        return `<svg class="w-20 h-20" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M12 2v16M8 2h8M8 2l-1 2h10l-1-2M7 4h10M7 4l1 10h8l1-10M10 14h4M10 16h4"></path>
                                </svg>`;
                    case 'cafe':
                        // Coffee cup icon
                        return `<svg class="w-20 h-20" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M5 4h14M5 4v12a2 2 0 002 2h10a2 2 0 002-2V4M5 4H3m16 0h2M8 18h8M8 18v2a2 2 0 002 2h4a2 2 0 002-2v-2M9 6h6M9 8h6"></path>
                                </svg>`;
                    default:
                        // Default restaurant icon (fork and knife)
                        return `<svg class="w-20 h-20" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M12 2v20M9 2l3-1 3 1M9 2v20M15 2v20M7 4h2M7 8h2M7 12h2M7 16h2M15 4h2M15 8h2M15 12h2M15 16h2"></path>
                                </svg>`;
                }
            }
            
            // Helper function to generate OpenStreetMap map tile URL (100% FREE - No API key required)
            // Uses OSM standard tile server - completely free and open source
            // License: ODbL (requires attribution to OpenStreetMap - included in footer)
            function getStreetViewImageUrl(lat, lng, width = 640, height = 360) {
                // OpenStreetMap Map Tiles - Free, no API key, no limits
                // Shows a detailed map view of the restaurant location
                const zoom = 17; // High zoom for detail (shows building/street level)
                const scale = Math.pow(2, zoom);
                const worldCoordinateX = (lng + 180) / 360 * scale;
                const worldCoordinateY = (1 - Math.log(Math.tan(lat * Math.PI / 180) + 1 / Math.cos(lat * Math.PI / 180)) / Math.PI) / 2 * scale;
                const tileX = Math.floor(worldCoordinateX);
                const tileY = Math.floor(worldCoordinateY);
                
                // Use OpenStreetMap standard tile server
                // Completely free - no API key, no registration, no limits
                // Note: For high-traffic sites, consider using your own tile server
                // See: https://operations.osmfoundation.org/policies/tiles/
                return `https://tile.openstreetmap.org/${zoom}/${tileX}/${tileY}.png`;
            }
            
            restaurantGrid.innerHTML = restaurantsToShow.map((restaurant, index) => {
                try {
                    // Get enhanced features
                    let availability = getAvailabilityStatus(restaurant);
                    let reviewSnippet = getReviewSnippet(restaurant);
                    let socialProof = getSocialProof(restaurant);
                    let quickActions = getQuickActions(restaurant);
                    let photoCount = getPhotoCount(restaurant);
                    let lastUpdated = getLastUpdated(restaurant);
                    
                    const category = getPrimaryCategory(restaurant, 'restaurant');
                    const colors = categoryColors[category] || categoryColors.restaurant;
                    const categoryLabel = categoryLabels[category] || 'Restaurant';
                    const categoryIcon = getCategoryIcon(category);
                    
                    // Get resort name(s) - show closest first
                    const closestResort = getClosestResort(restaurant);
                    const resortName = closestResort 
                        ? (skiEatsData.resorts?.find(r => r.id === closestResort.id)?.name || closestResort.id)
                        : (restaurant.location || 'Unknown Resort');
                    
                    // Generate satellite image URL
                    let satelliteImageUrl = null;
                    if (restaurant.coordinates && restaurant.coordinates.lat && restaurant.coordinates.lng) {
                        satelliteImageUrl = getSatelliteImageUrl(
                            restaurant.coordinates.lat, 
                            restaurant.coordinates.lng,
                            640,
                            360
                        );
                    }
                    
                    // Generate OpenStreetMap map tile URL (as fallback)
                    let mapImageUrl = null;
                    if (restaurant.coordinates && restaurant.coordinates.lat && restaurant.coordinates.lng) {
                        mapImageUrl = getStreetViewImageUrl(
                            restaurant.coordinates.lat, 
                            restaurant.coordinates.lng,
                            640,
                            360
                        );
                    }
                    
                    // Check for scraped logo and background photo (prioritize these)
                    const hasLogo = restaurant.logo && restaurant.logo.startsWith('http');
                    const hasBackgroundPhoto = restaurant.backgroundPhoto && restaurant.backgroundPhoto.startsWith('http');
                    
                    // Check if restaurant has a custom image (fallback)
                    const hasCustomImage = !hasBackgroundPhoto && restaurant.image && restaurant.image.startsWith('http');
                    const imageUrl = restaurant.image || '';
                    
                    // Logo URL
                    const logoUrl = restaurant.logo || null;
                    // Background photo URL (prioritize scraped, then custom image, then satellite image, then map)
                    const backgroundImageUrl = restaurant.backgroundPhoto || 
                                              (hasCustomImage ? imageUrl : (satelliteImageUrl || mapImageUrl)) || 
                                              null;
                    
                    // Rating display
                    const rating = restaurant.rating || 0;
                    
                    // Price range
                    const priceRange = restaurant.priceRange || restaurant.price || '';
                    
                    // Cuisine type
                    const cuisine = restaurant.cuisine || restaurant.type || '';
                    
                    // Prepare variables for template
                    const restaurantId = restaurant.id;
                    const restaurantName = (restaurant.name || 'Restaurant').replace(/'/g, "\\'");
                    
                    return `
                        <div class="restaurant-card-enhanced swipeable-card-mobile"
                             data-restaurant-id="${restaurantId}"
                             onclick="if(typeof showQuickPreview === 'function') showQuickPreview('${restaurantId}')"
                             role="article"
                             aria-label="${restaurantName}">
                            <!-- Badge Container -->
                            <div class="card-badge-container">
                                ${restaurant.featured ? '<span class="card-badge-new">Featured</span>' : ''}
                                ${restaurant.rating && restaurant.rating >= 4.5 ? '<span class="card-badge-trending">Popular</span>' : ''}
                                ${restaurant.new ? '<span class="card-badge-new">New</span>' : ''}
                            </div>
                        <div class="card-image-wrapper">
                            <!-- Hover Overlay -->
                            <div class="card-hover-overlay">
                                <div class="card-hover-info">
                                    <div class="card-hover-rating">★ ${rating > 0 ? rating.toFixed(1) : 'N/A'}</div>
                                    <div class="card-hover-price">${priceRange || 'Price varies'}</div>
                                </div>
                            </div>
                            <!-- Quick View Button -->
                            <button class="quick-view-btn" onclick="event.stopPropagation(); if(typeof showQuickPreview === 'function') showQuickPreview('${restaurantId}')">
                                Quick View
                            </button>
                            ${photoCount ? `
                                <div class="photo-count">
                                    <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"></path>
                                    </svg>
                                    ${photoCount}
                                </div>
                            ` : ''}
                            <a href="restaurant-detail.html?id=${restaurantId}" class="block w-full h-full relative" onclick="event.stopPropagation(); if(typeof trackEvent === 'function') trackEvent('Restaurant', 'Click', '${restaurantName.replace(/'/g, "\\'")}')">
                                ${backgroundImageUrl ? `
                                    <!-- Background Photo or Satellite Image -->
                                    <div class="absolute inset-0 w-full h-full">
                                        <img src="${backgroundImageUrl}" 
                                             alt="${restaurant.name}" 
                                             class="w-full h-full object-cover group-hover:scale-105 transition-transform duration-300"
                                             style="filter: brightness(0.7);"
                                             onerror="this.style.display='none'; this.nextElementSibling.style.display='block';"
                                             loading="lazy">
                                        <!-- Fallback if background photo/satellite fails -->
                                        <div class="hidden absolute inset-0 bg-gradient-to-br ${colors.bg}">
                                            <div class="absolute inset-0 flex items-center justify-center">
                                                <div class="${colors.icon}">
                                                    ${categoryIcon}
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                    ${logoUrl ? `
                                        <!-- Logo overlaying background photo/satellite image -->
                                        <div class="absolute inset-0 flex items-center justify-center z-10">
                                            <img src="${logoUrl}" 
                                                 alt="${restaurant.name} logo" 
                                                 class="max-w-[60%] max-h-[60%] object-contain drop-shadow-lg"
                                                 style="filter: drop-shadow(0 4px 6px rgba(0, 0, 0, 0.3));"
                                                 onerror="this.style.display='none';"
                                                 loading="lazy">
                                        </div>
                                    ` : `
                                        <!-- No logo, show category icon as fallback -->
                                        <div class="absolute inset-0 flex items-center justify-center z-10">
                                            <div class="${colors.icon} drop-shadow-lg" style="filter: drop-shadow(0 4px 6px rgba(0, 0, 0, 0.3));">
                                                ${categoryIcon}
                                            </div>
                                        </div>
                                    `}
                                ` : hasCustomImage ? `
                                    <!-- Custom Restaurant Image (if available - HTTP/HTTPS URLs only) -->
                                    <img src="${imageUrl}" 
                                         alt="${restaurant.name}" 
                                         class="w-full h-full object-cover group-hover:scale-105 transition-transform duration-300 cursor-pointer"
                                         onerror="this.style.display='none'; this.nextElementSibling.style.display='block';">
                                    ${logoUrl ? `
                                        <!-- Logo overlaying custom image -->
                                        <div class="absolute inset-0 flex items-center justify-center z-10">
                                            <img src="${logoUrl}" 
                                                 alt="${restaurant.name} logo" 
                                                 class="max-w-[60%] max-h-[60%] object-contain drop-shadow-lg"
                                                 style="filter: drop-shadow(0 4px 6px rgba(0, 0, 0, 0.3));"
                                                 onerror="this.style.display='none';"
                                                 loading="lazy">
                                        </div>
                                    ` : ''}
                                    <!-- Fallback to satellite image if custom image fails -->
                                    <div class="hidden">
                                        ${satelliteImageUrl ? `
                                            <img src="${satelliteImageUrl}" 
                                                 alt="Satellite view of ${restaurant.name}" 
                                                 class="w-full h-full object-cover group-hover:scale-105 transition-transform duration-300 cursor-pointer"
                                                 style="filter: brightness(0.7);"
                                                 onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';"
                                                 loading="lazy">
                                            ${logoUrl ? `
                                                <!-- Logo overlaying satellite image -->
                                                <div class="absolute inset-0 flex items-center justify-center z-10">
                                                    <img src="${logoUrl}" 
                                                         alt="${restaurant.name} logo" 
                                                         class="max-w-[60%] max-h-[60%] object-contain drop-shadow-lg"
                                                         style="filter: drop-shadow(0 4px 6px rgba(0, 0, 0, 0.3));"
                                                         onerror="this.style.display='none';"
                                                         loading="lazy">
                                                </div>
                                            ` : ''}
                                        ` : mapImageUrl ? `
                                            <img src="${mapImageUrl}" 
                                                 alt="Map view of ${restaurant.name}" 
                                                 class="w-full h-full object-cover group-hover:scale-105 transition-transform duration-300 cursor-pointer"
                                                 onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';"
                                                 loading="lazy">
                                        ` : ''}
                                        <div class="absolute inset-0 flex items-center justify-center hidden">
                                            <div class="${colors.icon}">
                                                ${categoryIcon}
                                            </div>
                                        </div>
                                    </div>
                                ` : satelliteImageUrl ? `
                                    <!-- Satellite Image -->
                                    <img src="${satelliteImageUrl}" 
                                         alt="Satellite view of ${restaurant.name}" 
                                         class="w-full h-full object-cover group-hover:scale-105 transition-transform duration-300 cursor-pointer"
                                         style="filter: brightness(0.7);"
                                         onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';"
                                         loading="lazy">
                                    ${logoUrl ? `
                                        <!-- Logo overlaying satellite image -->
                                        <div class="absolute inset-0 flex items-center justify-center z-10">
                                            <img src="${logoUrl}" 
                                                 alt="${restaurant.name} logo" 
                                                 class="max-w-[60%] max-h-[60%] object-contain drop-shadow-lg"
                                                 style="filter: drop-shadow(0 4px 6px rgba(0, 0, 0, 0.3));"
                                                 onerror="this.style.display='none';"
                                                 loading="lazy">
                                        </div>
                                    ` : `
                                        <!-- No logo, show category icon as fallback -->
                                        <div class="absolute inset-0 flex items-center justify-center z-10">
                                            <div class="${colors.icon} drop-shadow-lg" style="filter: drop-shadow(0 4px 6px rgba(0, 0, 0, 0.3));">
                                                ${categoryIcon}
                                            </div>
                                        </div>
                                    `}
                                    <!-- Fallback to icon if satellite image fails -->
                                    <div class="absolute inset-0 flex items-center justify-center hidden">
                                        <div class="${colors.icon}">
                                            ${categoryIcon}
                                        </div>
                                    </div>
                                ` : mapImageUrl ? `
                                    <!-- OpenStreetMap Map Tile (FREE - No API key required) -->
                                    <img src="${mapImageUrl}" 
                                         alt="Map view of ${restaurant.name}" 
                                         class="w-full h-full object-cover group-hover:scale-105 transition-transform duration-300 cursor-pointer"
                                         onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';"
                                         loading="lazy">
                                    ${logoUrl ? `
                                        <!-- Logo overlaying map -->
                                        <div class="absolute inset-0 flex items-center justify-center z-10">
                                            <img src="${logoUrl}" 
                                                 alt="${restaurant.name} logo" 
                                                 class="max-w-[60%] max-h-[60%] object-contain drop-shadow-lg bg-white/80 rounded-lg p-4"
                                                 style="filter: drop-shadow(0 4px 6px rgba(0, 0, 0, 0.3));"
                                                 onerror="this.style.display='none';"
                                                 loading="lazy">
                                        </div>
                                    ` : ''}
                                    <!-- Fallback to icon if map tile fails -->
                                    <div class="absolute inset-0 flex items-center justify-center hidden">
                                        <div class="${colors.icon}">
                                            ${categoryIcon}
                                        </div>
                                    </div>
                                    <!-- OpenStreetMap Attribution (Required by ODbL License) -->
                                    <div class="absolute bottom-2 right-2 bg-white/90 backdrop-blur-sm px-2 py-1 rounded text-xs text-gray-700 flex items-center gap-1 pointer-events-none">
                                        <a href="https://www.openstreetmap.org/copyright" target="_blank" rel="noopener noreferrer" class="flex items-center gap-1 text-gray-700 hover:text-[var(--accent-blue)]">
                                            <span>© OSM</span>
                                        </a>
                                    </div>
                                ` : `
                                    <!-- Fallback: Icon if no map available -->
                                    <div class="absolute inset-0 flex items-center justify-center">
                                        <div class="${colors.icon}">
                                            ${categoryIcon}
                                        </div>
                                    </div>
                                    ${logoUrl ? `
                                        <!-- Logo overlaying icon -->
                                        <div class="absolute inset-0 flex items-center justify-center z-10">
                                            <img src="${logoUrl}" 
                                                 alt="${restaurant.name} logo" 
                                                 class="max-w-[60%] max-h-[60%] object-contain"
                                                 onerror="this.style.display='none';"
                                                 loading="lazy">
                                        </div>
                                    ` : ''}
                                `}
                            </a>
                        </div>
                        <div class="p-6 flex flex-col flex-1">
                            <div class="flex items-start justify-between mb-3">
                                <div class="flex-1 min-w-0">
                                    <h3 class="text-xl font-bold text-gray-900 mb-2 leading-tight group-hover:text-[var(--accent-blue)] transition-colors duration-200">
                                        ${restaurant.name || 'Restaurant'}
                                    </h3>
                                    ${availability ? `
                                        <span class="inline-block availability-badge availability-${availability.status} mb-2">
                                            ${availability.label}
                                        </span>
                                    ` : ''}
                                </div>
                                <button class="favorite-btn opacity-70 hover:opacity-100 transition-all duration-200 p-2 rounded-full hover:bg-gray-50" 
                                        data-id="${restaurant.id}" 
                                        data-name="${restaurant.name}" 
                                        data-location="${resortName}" 
                                        data-rating="${rating}" 
                                        data-category="${category}" 
                                        onclick="event.preventDefault(); event.stopPropagation(); if(typeof toggleFavorite === 'function') toggleFavorite(this)">
                                    <svg class="w-5 h-5 text-gray-400 hover:text-red-500 transition-colors" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4.318 6.318a4.5 4.5 0 000 6.364L12 20.364l7.682-7.682a4.5 4.5 0 00-6.364-6.364L12 7.636l-1.318-1.318a4.5 4.5 0 00-6.364 0z"></path>
                                    </svg>
                                </button>
                            </div>
                            ${(() => {
                                const restaurantResorts = getRestaurantResorts(restaurant);
                                if (restaurantResorts.length === 0) {
                                    return `<p class="text-sm text-gray-600 mb-3">${restaurant.location || 'Location TBD'}${restaurant.distance ? ` • ${restaurant.distance.toFixed(1)} mi away` : ''}</p>`;
                                }
                                
                                if (restaurantResorts.length === 1) {
                                    // Single resort: show on one line with distance
                                    const r = restaurantResorts[0];
                                    const resort = skiEatsData.resorts?.find(res => res.id === r.id);
                                    const name = resort ? resort.name : r.id;
                                    const distanceText = r.distance !== null && r.distance !== undefined ? ` (${r.distance.toFixed(1)} mi)` : '';
                                    return `<p class="text-sm text-gray-600 mb-3">${name}${distanceText}${restaurant.distance ? ` • ${restaurant.distance.toFixed(1)} mi away` : ''}</p>`;
                                } else {
                                    // Multiple resorts: show each on separate line with distance
                                    const resortLines = restaurantResorts.map(r => {
                                        const resort = skiEatsData.resorts?.find(res => res.id === r.id);
                                        const name = resort ? resort.name : r.id;
                                        const distanceText = r.distance !== null && r.distance !== undefined ? ` (${r.distance.toFixed(1)} mi)` : '';
                                        return `<div class="text-sm text-gray-600">${name}${distanceText}</div>`;
                                    }).join('');
                                    return `<div class="mb-3 space-y-1">${resortLines}${restaurant.distance ? `<div class="text-sm text-gray-500 mt-1">${restaurant.distance.toFixed(1)} mi away</div>` : ''}</div>`;
                                }
                            })()}
                            <div class="flex items-center gap-3 mb-4">
                                ${rating > 0 ? `
                                    <div class="flex items-center gap-1.5">
                                        <svg class="w-5 h-5 text-yellow-500 fill-current" viewBox="0 0 20 20">
                                            <path d="M10 15l-5.878 3.09 1.123-6.545L.489 6.91l6.572-.955L10 0l2.939 5.955 6.572.955-4.756 4.635 1.123 6.545z"/>
                                        </svg>
                                        <span class="text-base font-bold text-gray-900">${rating.toFixed(1)}</span>
                                    </div>
                                ` : ''}
                                <span class="inline-block px-3 py-1.5 ${colors.badge} text-xs font-semibold rounded-full" data-category="${category}">
                                    ${categoryLabel}
                                </span>
                                ${cuisine ? `<span class="text-sm text-gray-600 font-medium truncate flex-1">${cuisine}</span>` : ''}
                            </div>
                            ${reviewSnippet ? `<p class="review-snippet">"${reviewSnippet}"</p>` : ''}
                            ${socialProof.length > 0 ? `
                                <div class="social-proof">
                                    ${socialProof.join(' • ')}
                                </div>
                            ` : ''}
                            ${quickActions.length > 0 ? `
                                <div class="quick-actions">
                                    ${quickActions.map(action => `
                                        <a href="${action.action}" class="quick-action-btn" onclick="event.stopPropagation()" target="_blank" rel="noopener">
                                            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                ${action.icon === 'phone' ? '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 5a2 2 0 012-2h3.28a1 1 0 01.948.684l1.498 4.493a1 1 0 01-.502 1.21l-2.257 1.13a11.042 11.042 0 005.516 5.516l1.13-2.257a1 1 0 011.21-.502l4.493 1.498a1 1 0 01.684.949V19a2 2 0 01-2 2h-1C9.716 21 3 14.284 3 6V5z"></path>' : ''}
                                                ${action.icon === 'map' ? '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17.657 16.657L13.414 20.9a1.998 1.998 0 01-2.827 0l-4.244-4.243a8 8 0 1111.314 0z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 11a3 3 0 11-6 0 3 3 0 016 0z"></path>' : ''}
                                                ${action.icon === 'calendar' ? '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z"></path>' : ''}
                                            </svg>
                                            ${action.label}
                                        </a>
                                    `).join('')}
                                </div>
                            ` : ''}
                            ${lastUpdated ? `<p class="last-updated">Updated ${lastUpdated}</p>` : ''}
                            <div class="flex items-center gap-2 mt-auto pt-4 border-t border-gray-100">
                                <a href="restaurant-detail.html?id=${restaurantId}" 
                                   class="flex-1 inline-flex items-center justify-center px-5 py-3 bg-[var(--accent-blue)] text-white rounded-xl text-sm font-semibold hover:bg-blue-600 transition-all duration-200 shadow-md hover:shadow-lg hover:scale-[1.02]"
                                   onclick="event.stopPropagation()">
                                    View Details
                                    <svg class="w-4 h-4 ml-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path>
                                    </svg>
                                </a>
                                <button onclick="event.stopPropagation(); if(typeof shareRestaurant === 'function') shareRestaurant('${restaurantId}')" 
                                        class="share-btn p-3 rounded-xl border border-gray-200 hover:bg-gray-50 hover:border-gray-300 transition-all duration-200" 
                                        aria-label="Share ${restaurantName}">
                                    <svg class="w-4 h-4 text-gray-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8.684 13.342C8.886 12.938 9 12.482 9 12c0-.482-.114-.938-.316-1.342m0 2.684a3 3 0 110-2.684m0 2.684l6.632 3.316m-6.632-6l6.632-3.316m0 0a3 3 0 105.367-2.684 3 3 0 00-5.367 2.684zm0 9.316a3 3 0 105.368 2.684 3 3 0 00-5.368-2.684z"></path>
                                    </svg>
                                </button>
                            </div>
                        </div>
                    </div>
                    `;
                } catch (error) {
                    console.error('Error rendering restaurant card:', error, restaurant);
                    return `<div class="restaurant-card bg-white border border-gray-200 rounded-lg p-6">
                        <h3 class="text-lg font-semibold mb-2">${restaurant.name || 'Restaurant'}</h3>
                        <p class="text-sm text-gray-600">Error loading restaurant details</p>
                    </div>`;
                }
            }).join('');
            
            // Re-initialize favorite states after rendering
            if (typeof loadFavoriteStates === 'function') {
                try {
                    loadFavoriteStates();
                } catch (e) {
                    console.warn('Error loading favorite states:', e);
                }
            }
            
            // Re-initialize favorite states after rendering
            if (typeof loadFavoriteStates === 'function') {
                loadFavoriteStates();
            }
            
            // Re-initialize fade-in animations
            const observerOptions = {
                threshold: 0.1,
                rootMargin: '0px 0px -50px 0px'
            };
            
            const observer = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        entry.target.style.opacity = '1';
                        entry.target.style.transform = 'translateY(0)';
                    }
                });
            }, observerOptions);
            
            document.querySelectorAll('#restaurantGrid > div').forEach(card => {
                card.style.opacity = '0';
                card.style.transform = 'translateY(20px)';
                card.style.transition = 'opacity 0.6s ease, transform 0.6s ease';
                observer.observe(card);
            });
            
            // Re-apply current filter after rendering
            const activeFilter = document.querySelector('.filter-btn.active')?.getAttribute('data-filter') || 'all';
            filterRestaurantCards(activeFilter);
            
            // Update "More" button visibility
            updateMoreButtonVisibility();
            } catch (error) {
                handleError(error, 'renderRestaurantCards');
            }
        }
        
        // Update "More" button visibility based on displayed count
        function updateMoreButtonVisibility() {
            const moreButton = document.getElementById('loadMoreRestaurantsBtn');
            if (!moreButton) return;
            
            const allSortedRestaurants = getSortedRestaurants();
            // Show button if there are more than 3 restaurants (initial display count)
            if (allSortedRestaurants.length > INITIAL_RESTAURANT_COUNT && displayedRestaurantCount < allSortedRestaurants.length) {
                moreButton.classList.remove('hidden');
            } else {
                moreButton.classList.add('hidden');
            }
        }
        
        // Load more restaurants
        function loadMoreRestaurants() {
            const allSortedRestaurants = getSortedRestaurants();
            const previousCount = displayedRestaurantCount;
            const newCount = displayedRestaurantCount + LOAD_MORE_COUNT;
            renderRestaurantCards(newCount);
            
            // Scroll to the first newly loaded card
            setTimeout(() => {
                const restaurantGrid = document.getElementById('restaurantGrid');
                if (restaurantGrid && restaurantGrid.children.length > previousCount) {
                    const firstNewCard = restaurantGrid.children[previousCount];
                    if (firstNewCard) {
                        firstNewCard.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                    }
                }
            }, 100);
        }
        
        // Try to get user location on page load if permission was previously granted
        function tryGetUserLocation() {
            const storedLocation = localStorage.getItem('snogrub_user_location');
            if (storedLocation) {
                try {
                    const location = JSON.parse(storedLocation);
                    // Check if location is recent (less than 24 hours old)
                    const age = Date.now() - (location.timestamp || 0);
                    const maxAge = 24 * 60 * 60 * 1000; // 24 hours
                    if (age < maxAge) {
                        // Location is recent, use it
                        renderResortCards();
                        renderRestaurantCards();
                        return;
                    }
                } catch (e) {
                    // Invalid stored location, continue to request new one
                }
            }
            
            // Try to get fresh location if geolocation is available
            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(
                    (position) => {
                        const { latitude, longitude } = position.coords;
                        localStorage.setItem('snogrub_user_location', JSON.stringify({
                            lat: latitude,
                            lng: longitude,
                            timestamp: Date.now()
                        }));
                        renderResortCards();
                        renderRestaurantCards();
                    },
                    (error) => {
                        // User denied or error getting location - show popular resorts and restaurants
                        // Don't show error for permission denied on initial load (user might not want to share location)
                        if (error.code !== error.PERMISSION_DENIED) {
                            handleError(error, 'getUserLocation');
                        }
                        renderResortCards();
                        renderRestaurantCards();
                    },
                    { timeout: 5000, maximumAge: 60000 } // 5 second timeout, accept cached location up to 1 minute old
                );
            } else {
                // Geolocation not supported - show popular resorts and restaurants
                renderResortCards();
                renderRestaurantCards();
            }
        }
        
        // Parallax scroll effect for hero background
        function initParallaxEffect() {
            const heroSection = document.getElementById('heroSection');
            const heroBackground = document.getElementById('heroBackground');
            
            if (!heroSection || !heroBackground) return;
            
            // Only enable parallax if user hasn't requested reduced motion
            if (window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                return;
            }
            
            function updateParallax() {
                const rect = heroSection.getBoundingClientRect();
                const scrollProgress = Math.max(0, Math.min(1, -rect.top / (rect.height * 0.5)));
                
                // Move background slower than scroll (parallax effect)
                const translateY = scrollProgress * 50; // Adjust speed here (lower = slower)
                heroBackground.style.transform = `translate3d(0, ${translateY}px, 0)`;
            }
            
            // Throttle scroll events for performance
            let ticking = false;
            window.addEventListener('scroll', () => {
                if (!ticking) {
                    window.requestAnimationFrame(() => {
                        updateParallax();
                        ticking = false;
                    });
                    ticking = true;
                }
            }, { passive: true });
            
            // Initial call
            updateParallax();
        }
        
        // Render resorts and restaurants when page loads
        // Wait for skiEatsData to be available before rendering cards
        let dataWaitAttempts = 0;
        const maxDataWaitAttempts = 50; // 5 seconds max wait (50 * 100ms)
        
        function waitForDataAndInit() {
            dataWaitAttempts++;
            
            if (typeof skiEatsData !== 'undefined' && skiEatsData && 
                ((skiEatsData.resorts && skiEatsData.resorts.length > 0) || 
                 (skiEatsData.restaurants && skiEatsData.restaurants.length > 0))) {
                // Data is loaded, proceed with initialization
                console.log('skiEatsData loaded successfully, initializing cards...');
                tryGetUserLocation();
                initParallaxEffect();
            } else if (dataWaitAttempts < maxDataWaitAttempts) {
                // Data not ready yet, wait a bit and check again
                if (dataWaitAttempts === 1) {
                    console.log('Waiting for skiEatsData to load...');
                }
                setTimeout(waitForDataAndInit, 100);
            } else {
                // Timeout reached - data.js may have failed to load
                console.error('Timeout waiting for skiEatsData to load after', maxDataWaitAttempts * 100, 'ms');
                console.log('skiEatsData status:', typeof skiEatsData, skiEatsData);
                // Try to initialize anyway (will show empty states if data is missing)
                tryGetUserLocation();
                initParallaxEffect();
            }
        }
        
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                waitForDataAndInit();
            });
        } else {
            waitForDataAndInit();
        }
        // Mobile Menu Toggle
        const mobileMenuButton = document.getElementById('mobileMenuButton');
        const mobileMenu = document.getElementById('mobileMenu');
        const menuIcon = document.getElementById('menuIcon');
        const closeIcon = document.getElementById('closeIcon');
        
        if (mobileMenuButton) {
            mobileMenuButton.addEventListener('click', () => {
                mobileMenu.classList.toggle('hidden');
                menuIcon.classList.toggle('hidden');
                closeIcon.classList.toggle('hidden');
            });
        }
        
        // Close mobile menu when clicking a link
        if (mobileMenu) {
            mobileMenu.querySelectorAll('a').forEach(link => {
                link.addEventListener('click', () => {
                    mobileMenu.classList.add('hidden');
                    menuIcon.classList.remove('hidden');
                    closeIcon.classList.add('hidden');
                });
            });
        }
        
        // Location Permission Modal
        const locationModal = document.getElementById('locationModal');
        const findNearMeBtn = document.getElementById('findNearMeBtn');
        const allowLocationBtn = document.getElementById('allowLocationBtn');
        const exploreBtn = document.getElementById('exploreBtn');
        const cancelModalBtn = document.getElementById('cancelModalBtn');
        
        // Navigate to restaurants page with location when "Find Restaurants Near Me" is clicked
        if (findNearMeBtn) {
            findNearMeBtn.addEventListener('click', () => {
                if (navigator.geolocation) {
                    // Request location permission and get coordinates
                    navigator.geolocation.getCurrentPosition(
                        (position) => {
                            const { latitude, longitude } = position.coords;
                            // Navigate to restaurants page with location parameters
                            window.location.href = `restaurants.html?lat=${latitude}&lng=${longitude}&nearby=true`;
                        },
                        (error) => {
                            // Handle location error
                            let errorMessage = 'Unable to get your location. ';
                            if (error.code === error.PERMISSION_DENIED) {
                                errorMessage += 'Please allow location access or search manually.';
                            } else if (error.code === error.POSITION_UNAVAILABLE) {
                                errorMessage += 'Location information is unavailable. Please search manually.';
                            } else {
                                errorMessage += 'Please try again or search manually.';
                            }
                            showErrorMessage('Location Error', errorMessage);
                        },
                        {
                            enableHighAccuracy: true,
                            timeout: 10000,
                            maximumAge: 0
                        }
                    );
                } else {
                    showErrorMessage('Geolocation not supported', 'Your browser doesn\'t support location services. Please use the search to find restaurants.');
                }
            });
        }
        
        // Close modal
        function closeModal() {
            if (locationModal) {
                locationModal.classList.remove('active');
            }
        }
        
        if (cancelModalBtn) {
            cancelModalBtn.addEventListener('click', closeModal);
        }
        
        // Close modal when clicking overlay
        if (locationModal) {
            locationModal.addEventListener('click', (e) => {
                if (e.target === locationModal) {
                    closeModal();
                }
            });
        }
        
        // Use My Location (from modal - kept for backward compatibility if modal is still used elsewhere)
        if (allowLocationBtn) {
            allowLocationBtn.addEventListener('click', () => {
                if (navigator.geolocation) {
                    navigator.geolocation.getCurrentPosition(
                        (position) => {
                            const { latitude, longitude } = position.coords;
                            // Navigate to restaurants page with location parameters
                            window.location.href = `restaurants.html?lat=${latitude}&lng=${longitude}&nearby=true`;
                        },
                        (error) => {
                            handleError(error, 'getUserLocation');
                            closeModal();
                        }
                    );
                } else {
                    showErrorMessage('Geolocation not supported', 'Your browser doesn\'t support location services. Please use the search to find restaurants.');
                    closeModal();
                }
            });
        }
        
        // Just Exploring
        if (exploreBtn) {
            exploreBtn.addEventListener('click', () => {
                closeModal();
                // Scroll to restaurants section
                const restaurantsSection = document.getElementById('restaurants');
                if (restaurantsSection) {
                    const offsetTop = restaurantsSection.offsetTop - 60;
                    window.scrollTo({
                        top: offsetTop,
                        behavior: 'smooth'
                    });
                }
            });
        }
        
        // Smooth scrolling for anchor links
        document.querySelectorAll('a[href^="#"]').forEach(anchor => {
            anchor.addEventListener('click', function (e) {
                e.preventDefault();
                const target = document.querySelector(this.getAttribute('href'));
                if (target) {
                    const offsetTop = target.offsetTop - 60; // Account for sticky nav
                    window.scrollTo({
                        top: offsetTop,
                        behavior: 'smooth'
                    });
                }
            });
        });
        
        // Enhanced Search Functionality with Autocomplete
        const searchInput = document.getElementById('searchInput');
        const autocompleteDropdown = document.getElementById('autocompleteDropdown');
        const suggestionsList = document.getElementById('suggestionsList');
        const recentSearchesSection = document.getElementById('recentSearchesSection');
        const recentSearchesList = document.getElementById('recentSearchesList');
        const noResults = document.getElementById('noResults');
        const clearSearchBtn = document.getElementById('clearSearchBtn');
        const clearRecentBtn = document.getElementById('clearRecentBtn');
        const searchIcon = document.getElementById('searchIcon');
        const searchContainer = document.getElementById('searchContainer');
        let selectedIndex = -1;
        let currentSuggestions = [];
        
        // Get recent searches from localStorage
        function getRecentSearches() {
            const recent = localStorage.getItem('snogrub_recent_searches');
            return recent ? JSON.parse(recent) : [];
        }
        
        // Save search to recent searches
        function saveRecentSearch(query) {
            if (!query || query.trim().length === 0) return;
            const recent = getRecentSearches();
            const trimmedQuery = query.trim();
            // Remove if already exists
            const filtered = recent.filter(s => s.toLowerCase() !== trimmedQuery.toLowerCase());
            // Add to beginning
            filtered.unshift(trimmedQuery);
            // Keep only last 5
            const limited = filtered.slice(0, 5);
            localStorage.setItem('snogrub_recent_searches', JSON.stringify(limited));
        }
        
        // Render recent searches
        function renderRecentSearches() {
            const recent = getRecentSearches();
            if (recent.length === 0) {
                recentSearchesSection.classList.add('hidden');
                return;
            }
            
            recentSearchesSection.classList.remove('hidden');
            recentSearchesList.innerHTML = recent.map(search => `
                <div class="recent-search-item" data-query="${search}">
                    <div class="recent-search-item-icon">
                        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                        </svg>
                    </div>
                    <div class="flex-1">
                        <div class="text-sm font-medium text-gray-900">${escapeHtml(search)}</div>
                    </div>
                </div>
            `).join('');
            
            // Add click handlers
            recentSearchesList.querySelectorAll('.recent-search-item').forEach(item => {
                item.addEventListener('click', () => {
                    const query = item.getAttribute('data-query');
                    searchInput.value = query;
                    searchInput.focus();
                    performSearch(query);
                });
            });
        }
        
        // Escape HTML to prevent XSS
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        // Highlight matching text
        function highlightText(text, query) {
            if (!query) return escapeHtml(text);
            const regex = new RegExp(`(${escapeRegex(query)})`, 'gi');
            return escapeHtml(text).replace(regex, '<span class="autocomplete-item-highlight">$1</span>');
        }
        
        // Escape regex special characters
        function escapeRegex(string) {
            return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        }
        
        // Extract city/state from location string
        function parseLocation(locationStr) {
            if (!locationStr) return { state: '', country: '', parts: [] };
            const parts = locationStr.split(',').map(p => p.trim());
            return {
                state: parts[0] || '',
                country: parts[1] || '',
                parts: parts
            };
        }
        
        // Extract city names from description (common ski resort cities)
        function extractCityFromDescription(description) {
            if (!description) return null;
            const desc = description.toLowerCase();
            // Common city patterns in descriptions
            const cityPatterns = [
                /nearby (?:the )?town of ([A-Z][a-z]+(?: [A-Z][a-z]+)?)/i,
                /located (?:in|at|near) ([A-Z][a-z]+(?: [A-Z][a-z]+)?)/i,
                /([A-Z][a-z]+(?: [A-Z][a-z]+)?), (?:Colorado|Utah|California|Vermont|New York|Wyoming|Montana|Idaho|Nevada|New Mexico|Maine|New Hampshire)/i,
                /([A-Z][a-z]+(?: [A-Z][a-z]+)?) (?:Village|Town|City)/i
            ];
            
            for (const pattern of cityPatterns) {
                const match = description.match(pattern);
                if (match && match[1]) {
                    return match[1].trim();
                }
            }
            return null;
        }
        
        // Get search suggestions from data
        function getSuggestions(query) {
            if (!query || query.trim().length < 2) return [];
            
            const lowerQuery = query.toLowerCase().trim();
            const suggestions = [];
            const seenLocations = new Set();
            const seenResorts = new Set();
            const seenRestaurants = new Set();
            
            // Check if skiEatsData is available
            if (typeof skiEatsData !== 'undefined') {
                // Search resorts first (they contain location info)
                if (skiEatsData.resorts) {
                    skiEatsData.resorts.forEach(resort => {
                        const resortName = resort.name.toLowerCase();
                        const resortLocation = resort.location?.toLowerCase() || '';
                        const parsedLocation = parseLocation(resort.location || '');
                        const stateLower = parsedLocation.state.toLowerCase();
                        const countryLower = parsedLocation.country.toLowerCase();
                        const description = resort.description?.toLowerCase() || '';
                        
                        // Check resort name
                        const nameMatch = resortName.includes(lowerQuery);
                        // Check full location string
                        const locationMatch = resortLocation.includes(lowerQuery);
                        // Check state/province
                        const stateMatch = stateLower.includes(lowerQuery);
                        // Check country
                        const countryMatch = countryLower.includes(lowerQuery);
                        // Check individual location parts
                        const partsMatch = parsedLocation.parts.some(part => 
                            part.toLowerCase().includes(lowerQuery)
                        );
                        // Check description for city names
                        const descriptionMatch = description.includes(lowerQuery);
                        
                        if (nameMatch || locationMatch || stateMatch || countryMatch || partsMatch || descriptionMatch) {
                            if (!seenResorts.has(resort.id)) {
                                seenResorts.add(resort.id);
                                suggestions.push({
                                    type: 'resort',
                                    title: resort.name,
                                    subtitle: resort.location || '',
                                    query: resort.name,
                                    url: `resort-detail.html?id=${resort.id}`
                                });
                            }
                            
                            // Also create location suggestion if query matches location parts
                            if ((stateMatch || partsMatch || locationMatch) && !seenLocations.has(resort.location)) {
                                seenLocations.add(resort.location);
                                suggestions.push({
                                    type: 'location',
                                    title: parsedLocation.state || resort.location,
                                    subtitle: `Ski resorts in ${resort.location}`,
                                    query: parsedLocation.state || resort.location,
                                    url: `restaurants.html?q=${encodeURIComponent(parsedLocation.state || resort.location)}`
                                });
                            }
                        }
                    });
                }
                
                // Search restaurants
                if (skiEatsData.restaurants) {
                    skiEatsData.restaurants.forEach(restaurant => {
                        const nameMatch = restaurant.name.toLowerCase().includes(lowerQuery);
                        const restaurantLocation = restaurant.location?.toLowerCase() || '';
                        const resortMatch = restaurant.resort?.toLowerCase().includes(lowerQuery);
                        const parsedLocation = parseLocation(restaurant.location || '');
                        const stateMatch = parsedLocation.state.toLowerCase().includes(lowerQuery);
                        const partsMatch = parsedLocation.parts.some(part => 
                            part.toLowerCase().includes(lowerQuery)
                        );
                        
                        if (nameMatch || restaurantLocation.includes(lowerQuery) || resortMatch || stateMatch || partsMatch) {
                            if (!seenRestaurants.has(restaurant.id)) {
                                seenRestaurants.add(restaurant.id);
                                suggestions.push({
                                    type: 'restaurant',
                                    title: restaurant.name,
                                    subtitle: `${restaurant.resort || ''} • ${restaurant.location || ''}`.trim(),
                                    query: restaurant.name,
                                    url: `restaurant-detail.html?id=${restaurant.id}`
                                });
                            }
                        }
                    });
                }
                
                // Search for common city names in resort names and descriptions
                // Common ski resort cities/towns (extracted from resort data)
                const commonCities = [
                    'Vail', 'Aspen', 'Breckenridge', 'Park City', 'Whistler', 'Vancouver', 
                    'Denver', 'Salt Lake City', 'Montreal', 'Quebec', 'Tahoe', 'Jackson Hole',
                    'Steamboat', 'Telluride', 'Sun Valley', 'Mammoth', 'Big Sky', 'Bend',
                    'Boulder', 'Bozeman', 'Burlington', 'Reno', 'Truckee', 'Frisco', 'Keystone',
                    'Colorado', 'Utah', 'California', 'Vermont', 'Wyoming', 'Montana', 'Idaho',
                    'Nevada', 'New Mexico', 'Maine', 'New Hampshire', 'British Columbia', 'Quebec'
                ];
                
                commonCities.forEach(city => {
                    const cityLower = city.toLowerCase();
                    // Check if the city name starts with or contains the query
                    if (cityLower.includes(lowerQuery)) {
                        // Find resorts near this city
                        const matchingResorts = skiEatsData.resorts?.filter(resort => {
                            const desc = resort.description?.toLowerCase() || '';
                            const name = resort.name.toLowerCase();
                            const location = resort.location?.toLowerCase() || '';
                            const parsedLoc = parseLocation(resort.location || '');
                            const stateLower = parsedLoc.state.toLowerCase();
                            
                            return desc.includes(cityLower) || 
                                   name.includes(cityLower) || 
                                   location.includes(cityLower) ||
                                   stateLower.includes(cityLower);
                        }) || [];
                        
                        if (matchingResorts.length > 0 && !seenLocations.has(city)) {
                            seenLocations.add(city);
                            suggestions.push({
                                type: 'location',
                                title: city,
                                subtitle: `${matchingResorts.length} resort${matchingResorts.length > 1 ? 's' : ''} in ${city}`,
                                query: city,
                                url: `restaurants.html?q=${encodeURIComponent(city)}`
                            });
                        }
                    }
                });
            }
            
            // Sort suggestions: exact matches first, then by type (location, resort, restaurant)
            suggestions.sort((a, b) => {
                const aExact = a.title.toLowerCase() === lowerQuery || a.query.toLowerCase() === lowerQuery;
                const bExact = b.title.toLowerCase() === lowerQuery || b.query.toLowerCase() === lowerQuery;
                if (aExact && !bExact) return -1;
                if (!aExact && bExact) return 1;
                
                const typeOrder = { location: 0, resort: 1, restaurant: 2 };
                return (typeOrder[a.type] || 3) - (typeOrder[b.type] || 3);
            });
            
            // Limit to 10 suggestions (increased from 8 to show more location options)
            return suggestions.slice(0, 10);
        }
        
        // Render suggestions
        function renderSuggestions(suggestions) {
            if (suggestions.length === 0) {
                suggestionsList.innerHTML = '';
                noResults.classList.remove('hidden');
                return;
            }
            
            noResults.classList.add('hidden');
            currentSuggestions = suggestions;
            
            suggestionsList.innerHTML = suggestions.map((suggestion, index) => {
                const iconClass = suggestion.type === 'restaurant' ? 'restaurant' : 
                                 suggestion.type === 'resort' ? 'resort' : 'location';
                const iconSvg = suggestion.type === 'restaurant' 
                    ? '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 12l2-2m0 0l7-7 7 7M5 10v10a1 1 0 001 1h3m10-11l2 2m-2-2v10a1 1 0 01-1 1h-3m-6 0a1 1 0 001-1v-4a1 1 0 011-1h2a1 1 0 011 1v4a1 1 0 001 1m-6 0h6"></path>'
                    : suggestion.type === 'resort'
                    ? '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 3v4M3 5h4M6 17v4m-2-2h4m5-16l2.286 6.857L21 12l-5.714 2.143L13 21l-2.286-6.857L5 12l5.714-2.143L13 3z"></path>'
                    : '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17.657 16.657L13.414 20.9a1.998 1.998 0 01-2.827 0l-4.244-4.243a8 8 0 1111.314 0z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 11a3 3 0 11-6 0 3 3 0 016 0z"></path>';
                
                return `
                    <div class="autocomplete-item" data-index="${index}" data-query="${escapeHtml(suggestion.query)}" data-url="${suggestion.url || ''}">
                        <div class="autocomplete-item-icon ${iconClass}">
                            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                ${iconSvg}
                            </svg>
                        </div>
                        <div class="autocomplete-item-content">
                            <div class="autocomplete-item-title">${highlightText(suggestion.title, searchInput.value)}</div>
                            <div class="autocomplete-item-subtitle">${highlightText(suggestion.subtitle, searchInput.value)}</div>
                        </div>
                    </div>
                `;
            }).join('');
            
            // Add click handlers
            suggestionsList.querySelectorAll('.autocomplete-item').forEach(item => {
                item.addEventListener('click', () => {
                    const query = item.getAttribute('data-query');
                    const url = item.getAttribute('data-url');
                    if (url) {
                        window.location.href = url;
                    } else {
                        searchInput.value = query;
                        performSearch(query);
                    }
                });
            });
        }
        
        // Show/hide autocomplete dropdown
        function showAutocomplete() {
            if (autocompleteDropdown) {
                autocompleteDropdown.classList.remove('hidden');
            }
        }
        
        function hideAutocomplete() {
            if (autocompleteDropdown) {
                autocompleteDropdown.classList.add('hidden');
            }
            selectedIndex = -1;
        }
        
        // Update autocomplete based on input
        function updateAutocomplete() {
            const query = searchInput.value.trim();
            
            // Show/hide clear button
            if (clearSearchBtn) {
                if (query.length > 0) {
                    clearSearchBtn.classList.remove('opacity-0', 'pointer-events-none');
                } else {
                    clearSearchBtn.classList.add('opacity-0', 'pointer-events-none');
                }
            }
            
            if (query.length === 0) {
                // Show recent searches when empty
                renderRecentSearches();
                if (getRecentSearches().length > 0) {
                    showAutocomplete();
                } else {
                    hideAutocomplete();
                }
                return;
            }
            
            if (query.length < 2) {
                hideAutocomplete();
                return;
            }
            
            const suggestions = getSuggestions(query);
            renderSuggestions(suggestions);
            showAutocomplete();
        }
        
        // Perform search
        function performSearch(query) {
            saveRecentSearch(query);
            hideAutocomplete();
            // Form will submit naturally or you can navigate programmatically
            if (query.trim()) {
                window.location.href = `restaurants.html?q=${encodeURIComponent(query.trim())}`;
            }
        }
        
        // Search input event handlers
        if (searchInput) {
            // Input event
            searchInput.addEventListener('input', () => {
                updateAutocomplete();
                updateSearchAndFilter();
            });
            
            // Focus event
            searchInput.addEventListener('focus', () => {
                searchIcon?.classList.add('focused');
                const query = searchInput.value.trim();
                if (query.length === 0) {
                    renderRecentSearches();
                    if (getRecentSearches().length > 0) {
                        showAutocomplete();
                    }
                } else if (query.length >= 2) {
                    updateAutocomplete();
                }
            });
            
            // Blur event (with delay to allow clicks on suggestions)
            searchInput.addEventListener('blur', () => {
                searchIcon?.classList.remove('focused');
                setTimeout(() => {
                    hideAutocomplete();
                }, 200);
            });
            
            // Keyboard navigation
            searchInput.addEventListener('keydown', (e) => {
                if (!autocompleteDropdown || autocompleteDropdown.classList.contains('hidden')) {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        performSearch(searchInput.value);
                    }
                    return;
                }
                
                const items = suggestionsList.querySelectorAll('.autocomplete-item');
                
                if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    selectedIndex = Math.min(selectedIndex + 1, items.length - 1);
                    items.forEach((item, idx) => {
                        item.classList.toggle('selected', idx === selectedIndex);
                    });
                    if (items[selectedIndex]) {
                        items[selectedIndex].scrollIntoView({ block: 'nearest' });
                    }
                } else if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    selectedIndex = Math.max(selectedIndex - 1, -1);
                    items.forEach((item, idx) => {
                        item.classList.toggle('selected', idx === selectedIndex);
                    });
                } else if (e.key === 'Enter') {
                    e.preventDefault();
                    if (selectedIndex >= 0 && items[selectedIndex]) {
                        items[selectedIndex].click();
                    } else {
                        performSearch(searchInput.value);
                    }
                } else if (e.key === 'Escape') {
                    hideAutocomplete();
                    searchInput.blur();
                }
            });
        }
        
        // Clear search button
        if (clearSearchBtn) {
            clearSearchBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                searchInput.value = '';
                searchInput.focus();
                updateAutocomplete();
                updateSearchAndFilter();
            });
        }
        
        // Clear recent searches
        if (clearRecentBtn) {
            clearRecentBtn.addEventListener('click', () => {
                localStorage.removeItem('snogrub_recent_searches');
                renderRecentSearches();
            });
        }
        
        // Close dropdown when clicking outside
        document.addEventListener('click', (e) => {
            if (searchContainer && !searchContainer.contains(e.target)) {
                hideAutocomplete();
            }
        });
        
        // Filter chip functionality
        const filterChips = document.querySelectorAll('.filter-chip');
        filterChips.forEach(chip => {
            chip.addEventListener('click', () => {
                const filter = chip.getAttribute('data-filter');
                // Toggle active state
                chip.classList.toggle('active');
                // Navigate to restaurants page with filter
                if (chip.classList.contains('active')) {
                    window.location.href = `restaurants.html?filter=${encodeURIComponent(filter)}`;
                }
            });
        });
        
        function updateSearchAndFilter() {
            const restaurantCards = document.querySelectorAll('#restaurantGrid > div');
            const searchTerm = searchInput ? searchInput.value.toLowerCase().trim() : '';
            
            // Get current active filter
            const activeFilter = document.querySelector('.filter-btn.active')?.getAttribute('data-filter') || 'all';
            
            restaurantCards.forEach(card => {
                const title = card.querySelector('h3')?.textContent.toLowerCase() || '';
                const location = card.querySelector('p')?.textContent.toLowerCase() || '';
                const categoryBadge = card.querySelector('[data-category]');
                const category = categoryBadge?.getAttribute('data-category') || '';
                const categoryText = categoryBadge?.textContent.toLowerCase() || '';
                
                // Check search match
                const searchMatches = title.includes(searchTerm) || 
                                     location.includes(searchTerm) || 
                                     categoryText.includes(searchTerm);
                
                // Check filter match
                const filterMatches = activeFilter === 'all' || category === activeFilter;
                
                if (searchMatches && filterMatches && (searchTerm === '' || searchMatches)) {
                    card.style.display = '';
                    card.style.opacity = '1';
                } else {
                    card.style.display = 'none';
                }
            });
        }
        
        // Filter Functionality
        const filterButtons = document.querySelectorAll('.filter-btn');
        
        function filterRestaurantCards(filter) {
            const restaurantCards = document.querySelectorAll('#restaurantGrid > div');
            
            restaurantCards.forEach(card => {
                if (filter === 'all') {
                    card.style.display = '';
                    card.style.opacity = '1';
                } else {
                    // Find the category badge inside the card
                    const categoryBadge = card.querySelector('[data-category]');
                    const category = categoryBadge?.getAttribute('data-category') || '';
                    
                    if (category === filter) {
                        card.style.display = '';
                        card.style.opacity = '1';
                    } else {
                        card.style.display = 'none';
                    }
                }
            });
        }
        
        // Use event delegation for filter buttons to handle dynamically rendered cards
        document.addEventListener('click', (e) => {
            if (e.target.closest('.filter-btn')) {
                const button = e.target.closest('.filter-btn');
                const filterButtons = document.querySelectorAll('.filter-btn');
                
                // Update active state
                filterButtons.forEach(btn => {
                    btn.classList.remove('active', 'bg-[var(--accent-blue)]', 'text-white');
                    btn.classList.add('bg-white', 'text-gray-700', 'border', 'border-gray-300');
                });
                
                button.classList.add('active', 'bg-[var(--accent-blue)]', 'text-white');
                button.classList.remove('bg-white', 'text-gray-700', 'border', 'border-gray-300');
                
                // Filter cards
                const filter = button.getAttribute('data-filter');
                filterRestaurantCards(filter);
                
                // Also update search results if there's a search term
                if (searchInput && searchInput.value.trim()) {
                    updateSearchAndFilter();
                }
            }
            
            // Handle "More" button click
            if (e.target.id === 'loadMoreRestaurantsBtn' || e.target.closest('#loadMoreRestaurantsBtn')) {
                loadMoreRestaurants();
            }
        });
        
        // Fade-in animation on scroll for cards
        const observerOptions = {
            threshold: 0.1,
            rootMargin: '0px 0px -50px 0px'
        };
        
        const observer = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    entry.target.style.opacity = '1';
                    entry.target.style.transform = 'translateY(0)';
                }
            });
        }, observerOptions);
        
        // Observe all cards for fade-in effect
        document.querySelectorAll('a[class*="group"]').forEach(card => {
            card.style.opacity = '0';
            card.style.transform = 'translateY(20px)';
            card.style.transition = 'opacity 0.6s ease, transform 0.6s ease';
            observer.observe(card);
        });
        
        // Favorites Functionality
        function toggleFavorite(button) {
            try {
                const id = button.dataset.id;
                const name = button.dataset.name;
                const location = button.dataset.location;
                const rating = button.dataset.rating;
                const category = button.dataset.category;
                
                let favorites = JSON.parse(localStorage.getItem('skieats_favorites') || '[]');
                const index = favorites.findIndex(f => f.id === id);
                const icon = button.querySelector('svg');
                
                if (index > -1) {
                    favorites.splice(index, 1);
                    icon.classList.remove('fill-red-500', 'text-red-500');
                    icon.classList.add('fill-none', 'stroke-current');
                    showSuccessMessage(`${name} removed from favorites`);
                } else {
                    favorites.push({ id, name, location, rating, category });
                    icon.classList.remove('fill-none', 'stroke-current');
                    icon.classList.add('fill-red-500', 'text-red-500');
                    showSuccessMessage(`${name} added to favorites`);
                }
                
                localStorage.setItem('skieats_favorites', JSON.stringify(favorites));
            } catch (error) {
                // Handle localStorage errors (e.g., private browsing mode)
                if (error.name === 'QuotaExceededError') {
                    showErrorMessage('Storage Full', 'Please clear some space in your browser storage to save favorites.');
                } else if (error.name === 'SecurityError') {
                    showErrorMessage('Storage Not Available', 'Favorites are not available in private browsing mode.');
                } else {
                    handleError(error, 'toggleFavorite');
                }
            }
        }
        
        // Load favorite states on homepage
        function loadFavoriteStates() {
            const favorites = JSON.parse(localStorage.getItem('skieats_favorites') || '[]');
            const favoriteIds = favorites.map(f => f.id);
            
            document.querySelectorAll('.favorite-btn-home').forEach(button => {
                const id = button.dataset.id;
                const icon = button.querySelector('svg');
                
                if (favoriteIds.includes(id)) {
                    icon.classList.remove('fill-none', 'stroke-current');
                    icon.classList.add('fill-red-500', 'text-red-500');
                }
            });
        }
        
        loadFavoriteStates();
        
        // Map Data - Resorts and Restaurants
        // Build mapData dynamically from skiEatsData to only include resorts/restaurants with actual information
        // This ensures the map only shows locations that have been added to the data
        const mapData = {
            resorts: [],
            restaurants: []
        };
        
        // Helper function to build mapData from skiEatsData
        function buildMapDataFromSkiEats() {
            if (typeof skiEatsData === 'undefined' || !skiEatsData) {
                console.warn('skiEatsData not available yet, map will be empty');
                return;
            }
            
            // Build resorts array from skiEatsData
            if (skiEatsData.resorts && Array.isArray(skiEatsData.resorts)) {
                mapData.resorts = skiEatsData.resorts.map(resort => ({
                    name: resort.name,
                    lat: resort.coordinates.lat,
                    lng: resort.coordinates.lng,
                    location: resort.location,
                    type: 'resort',
                    id: resort.id // Store ID for easier lookup
                }));
            }
            
            // Build restaurants array from skiEatsData
            if (skiEatsData.restaurants && Array.isArray(skiEatsData.restaurants)) {
                mapData.restaurants = skiEatsData.restaurants.map(restaurant => ({
                    name: restaurant.name,
                    lat: restaurant.coordinates.lat,
                    lng: restaurant.coordinates.lng,
                    location: restaurant.location || restaurant.resort || '',
                    type: 'restaurant',
                    category: restaurant.category || 'restaurant',
                    id: restaurant.id // Store ID for easier lookup
                }));
            }
            
            console.log(`Map data built: ${mapData.resorts.length} resorts, ${mapData.restaurants.length} restaurants`);
        }
        
        // Build map data immediately if skiEatsData is available, otherwise wait for it
        if (typeof skiEatsData !== 'undefined' && skiEatsData) {
            buildMapDataFromSkiEats();
        } else {
            // Wait for skiEatsData to load (it's loaded from data.js)
            const checkSkiEatsData = setInterval(() => {
                if (typeof skiEatsData !== 'undefined' && skiEatsData) {
                    buildMapDataFromSkiEats();
                    clearInterval(checkSkiEatsData);
                }
            }, 100);
            
            // Stop checking after 5 seconds
            setTimeout(() => {
                clearInterval(checkSkiEatsData);
            }, 5000);
        }
        
        // Initialize Map
        let mapInstance = null;
        let markers = [];
        let resortMarkers = [];
        let restaurantMarkers = [];
        let userLocationMarker = null;
        let currentFilter = 'all';
        // Store marker references by ID for quick lookup
        let markerMap = new Map(); // key: 'restaurant-{id}' or 'resort-{id}', value: marker
        
        // Other Places Markers
        let otherPlacesMarkers = {
            fuel: [],
            hotel: [],
            parking: [],
            atm: [],
            pharmacy: []
        };
        let activeOtherPlacesTypes = new Set();
        
        function initMap() {
            try {
                // Ensure mapData is built before initializing map
                if (typeof skiEatsData !== 'undefined' && skiEatsData) {
                    buildMapDataFromSkiEats();
                }
                
                // Create map without initial view - we'll set it based on marker bounds
                mapInstance = L.map('mapContainer', {
                    maxBounds: null // Will be set after markers are added
                });
                
                // Add OpenStreetMap tiles
                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    attribution: '© OpenStreetMap contributors',
                    maxZoom: 19
                }).addTo(mapInstance);
            } catch (error) {
                handleError(error, 'initMap');
                const mapLoading = document.getElementById('mapLoading');
                if (mapLoading) {
                    mapLoading.innerHTML = `
                        <div class="text-center py-8">
                            <svg class="w-12 h-12 mx-auto text-red-400 mb-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                            </svg>
                            <p class="text-red-600 font-medium">Failed to load map</p>
                            <p class="text-sm text-gray-600 mt-2">Please refresh the page</p>
                        </div>
                    `;
                }
                return;
            }
            
            // Store map instance globally
            window.mapInstance = mapInstance;
            window.userLocationMarker = null;
            
            // Add resort markers - only for resorts that have data
            mapData.resorts.forEach(resort => {
                // Get resort data using the stored ID
                const resortData = resort.id ? skiEatsData?.resorts?.find(r => r.id === resort.id) : null;
                
                // Skip if no data found (shouldn't happen since mapData is built from skiEatsData, but safety check)
                if (!resortData && !resort.id) {
                    console.warn(`Skipping resort ${resort.name} - no data found`);
                    return;
                }
                
                const icon = L.divIcon({
                    className: 'resort-marker',
                    html: '<div style="width: 32px; height: 32px; background: #0071e3; border: 3px solid white; border-radius: 50%; box-shadow: 0 2px 8px rgba(0,0,0,0.3); display: flex; align-items: center; justify-content: center;"><svg width="16" height="16" fill="white" viewBox="0 0 24 24"><path d="M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5"/></svg></div>',
                    iconSize: [32, 32],
                    iconAnchor: [16, 16]
                });
                
                // Use stored ID or fallback to creating slug from name
                const resortId = resort.id || resort.name.toLowerCase().replace(/[^a-z0-9]+/g, '-');
                const resortLink = `resort-detail.html?id=${resortId}`;
                
                // Create directions URLs
                const googleMapsUrl = `https://www.google.com/maps/dir/?api=1&destination=${resort.lat},${resort.lng}`;
                const appleMapsUrl = `https://maps.apple.com/?daddr=${resort.lat},${resort.lng}`;
                const wazeUrl = `https://waze.com/ul?ll=${resort.lat},${resort.lng}&navigate=yes`;
                
                // Get description preview for popup
                let descriptionPreview = '';
                if (resortData && resortData.description) {
                    // Get first 150 characters of description, ending at a sentence
                    const desc = resortData.description.trim();
                    const preview = desc.length > 150 ? desc.substring(0, 150) : desc;
                    const lastPeriod = preview.lastIndexOf('.');
                    descriptionPreview = lastPeriod > 50 ? preview.substring(0, lastPeriod + 1) : preview + '...';
                } else {
                    descriptionPreview = 'Click to view full resort information.';
                }
                
                // Get additional info if available
                let additionalInfo = '';
                if (resortData) {
                    const infoParts = [];
                    if (resortData.terrain && resortData.terrain.skiableAcres) {
                        infoParts.push(`${resortData.terrain.skiableAcres.toLocaleString()} acres`);
                    }
                    if (resortData.season && resortData.season.averageSnowfall) {
                        infoParts.push(`${resortData.season.averageSnowfall}" annual snowfall`);
                    }
                    if (infoParts.length > 0) {
                        additionalInfo = `<p style="font-size: 12px; color: #6b7280; margin: 8px 0;">${infoParts.join(' • ')}</p>`;
                    }
                }
                
                const marker = L.marker([resort.lat, resort.lng], { icon: icon })
                    .addTo(mapInstance)
                    .bindPopup(`
                        <div class="map-marker-popup">
                            <h3>${resort.name}</h3>
                            <p style="color: #6b7280; font-size: 13px; margin-bottom: 8px;">${resort.location}</p>
                            ${additionalInfo}
                            <p style="font-size: 13px; color: #374151; line-height: 1.5; margin: 12px 0;">${descriptionPreview}</p>
                            <p style="color: #0071e3; font-weight: 500; margin-bottom: 12px; font-size: 12px;">Ski Resort</p>
                            <div style="display: flex; gap: 8px; flex-wrap: wrap; margin-bottom: 8px;">
                                <a href="${resortLink}" style="display: inline-block; padding: 8px 16px; background: #0071e3; color: white; border-radius: 20px; text-decoration: none; font-size: 14px; font-weight: 500; transition: opacity 0.2s;" onmouseover="this.style.opacity='0.9'" onmouseout="this.style.opacity='1'">
                                    View Resort →
                                </a>
                                <a href="${googleMapsUrl}" target="_blank" rel="noopener noreferrer" style="display: inline-block; padding: 8px 16px; background: #10b981; color: white; border-radius: 20px; text-decoration: none; font-size: 14px; font-weight: 500; transition: opacity 0.2s;" onmouseover="this.style.opacity='0.9'" onmouseout="this.style.opacity='1'">
                                    🗺️ Directions
                                </a>
                            </div>
                            <div style="display: flex; gap: 6px; flex-wrap: wrap; margin-top: 8px;">
                                <a href="${googleMapsUrl}" target="_blank" rel="noopener noreferrer" style="font-size: 11px; color: #6b7280; text-decoration: none; padding: 4px 8px; border: 1px solid #e5e7eb; border-radius: 12px; transition: all 0.2s;" onmouseover="this.style.backgroundColor='#f3f4f6'" onmouseout="this.style.backgroundColor='transparent'">Google Maps</a>
                                <a href="${appleMapsUrl}" target="_blank" rel="noopener noreferrer" style="font-size: 11px; color: #6b7280; text-decoration: none; padding: 4px 8px; border: 1px solid #e5e7eb; border-radius: 12px; transition: all 0.2s;" onmouseover="this.style.backgroundColor='#f3f4f6'" onmouseout="this.style.backgroundColor='transparent'">Apple Maps</a>
                                <a href="${wazeUrl}" target="_blank" rel="noopener noreferrer" style="font-size: 11px; color: #6b7280; text-decoration: none; padding: 4px 8px; border: 1px solid #e5e7eb; border-radius: 12px; transition: all 0.2s;" onmouseover="this.style.backgroundColor='#f3f4f6'" onmouseout="this.style.backgroundColor='transparent'">Waze</a>
                            </div>
                        </div>
                    `);
                
                markers.push(marker);
                resortMarkers.push(marker);
                // Store marker reference by resort name for lookup
                if (resortData) {
                    markerMap.set(`resort-${resortData.id}`, marker);
                }
                markerMap.set(`resort-${resort.name.toLowerCase().replace(/\s+/g, '-')}`, marker);
            });
            
            // Add restaurant markers - only for restaurants that have data
            mapData.restaurants.forEach(restaurant => {
                // Get restaurant data using the stored ID
                const restaurantData = restaurant.id ? skiEatsData?.restaurants?.find(r => r.id === restaurant.id) : null;
                
                // Skip if no data found (shouldn't happen since mapData is built from skiEatsData, but safety check)
                if (!restaurantData && !restaurant.id) {
                    console.warn(`Skipping restaurant ${restaurant.name} - no data found`);
                    return;
                }
                
                const colors = {
                    restaurant: '#10b981',
                    bar: '#3b82f6',
                    cafe: '#f59e0b'
                };
                
                const icon = L.divIcon({
                    className: 'restaurant-marker',
                    html: `<div style="width: 24px; height: 24px; background: ${colors[restaurant.category] || '#6b7280'}; border: 2px solid white; border-radius: 50%; box-shadow: 0 2px 6px rgba(0,0,0,0.3);"></div>`,
                    iconSize: [24, 24],
                    iconAnchor: [12, 12]
                });
                
                // Use stored ID or fallback to creating slug from name
                const restaurantId = restaurant.id || restaurant.name.toLowerCase().replace(/[^a-z0-9]+/g, '-');
                const restaurantLink = `restaurant-detail.html?id=${restaurantId}`;
                const categoryColor = colors[restaurant.category] || '#6b7280';
                const categoryLabel = restaurant.category === 'bar' ? 'Après Bar' : restaurant.category === 'cafe' ? 'Café' : 'Restaurant';
                
                // Create directions URLs
                const googleMapsUrl = `https://www.google.com/maps/dir/?api=1&destination=${restaurant.lat},${restaurant.lng}`;
                const appleMapsUrl = `https://maps.apple.com/?daddr=${restaurant.lat},${restaurant.lng}`;
                const wazeUrl = `https://waze.com/ul?ll=${restaurant.lat},${restaurant.lng}&navigate=yes`;
                
                const marker = L.marker([restaurant.lat, restaurant.lng], { icon: icon })
                    .addTo(mapInstance)
                    .bindPopup(`
                        <div class="map-marker-popup">
                            <h3>${restaurant.name}</h3>
                            <p>${restaurant.location}</p>
                            <p style="color: ${categoryColor}; font-weight: 500; text-transform: capitalize; margin-bottom: 12px;">
                                ${categoryLabel}
                            </p>
                            <div style="display: flex; gap: 8px; flex-wrap: wrap; margin-bottom: 8px;">
                                <a href="${restaurantLink}" style="display: inline-block; padding: 8px 16px; background: ${categoryColor}; color: white; border-radius: 20px; text-decoration: none; font-size: 14px; font-weight: 500; transition: opacity 0.2s;" onmouseover="this.style.opacity='0.9'" onmouseout="this.style.opacity='1'">
                                    View Details →
                                </a>
                                <a href="${googleMapsUrl}" target="_blank" rel="noopener noreferrer" style="display: inline-block; padding: 8px 16px; background: #10b981; color: white; border-radius: 20px; text-decoration: none; font-size: 14px; font-weight: 500; transition: opacity 0.2s;" onmouseover="this.style.opacity='0.9'" onmouseout="this.style.opacity='1'">
                                    🗺️ Directions
                                </a>
                            </div>
                            <div style="display: flex; gap: 6px; flex-wrap: wrap; margin-top: 8px;">
                                <a href="${googleMapsUrl}" target="_blank" rel="noopener noreferrer" style="font-size: 11px; color: #6b7280; text-decoration: none; padding: 4px 8px; border: 1px solid #e5e7eb; border-radius: 12px; transition: all 0.2s;" onmouseover="this.style.backgroundColor='#f3f4f6'" onmouseout="this.style.backgroundColor='transparent'">Google Maps</a>
                                <a href="${appleMapsUrl}" target="_blank" rel="noopener noreferrer" style="font-size: 11px; color: #6b7280; text-decoration: none; padding: 4px 8px; border: 1px solid #e5e7eb; border-radius: 12px; transition: all 0.2s;" onmouseover="this.style.backgroundColor='#f3f4f6'" onmouseout="this.style.backgroundColor='transparent'">Apple Maps</a>
                                <a href="${wazeUrl}" target="_blank" rel="noopener noreferrer" style="font-size: 11px; color: #6b7280; text-decoration: none; padding: 4px 8px; border: 1px solid #e5e7eb; border-radius: 12px; transition: all 0.2s;" onmouseover="this.style.backgroundColor='#f3f4f6'" onmouseout="this.style.backgroundColor='transparent'">Waze</a>
                            </div>
                        </div>
                    `);
                
                markers.push(marker);
                restaurantMarkers.push(marker);
                // Store marker reference by restaurant name for lookup
                if (restaurantData) {
                    markerMap.set(`restaurant-${restaurantData.id}`, marker);
                }
                markerMap.set(`restaurant-${restaurant.name.toLowerCase().replace(/[^a-z0-9]+/g, '-')}`, marker);
            });
            
            // Calculate bounds of all markers and set map view and maxBounds
            if (markers.length > 0) {
                const group = new L.featureGroup(markers);
                const bounds = group.getBounds();
                
                // Set maxBounds to prevent zooming out beyond markers (with small padding)
                const paddedBounds = bounds.pad(0.1);
                mapInstance.setMaxBounds(paddedBounds);
                
                // Fit map to show all markers
                mapInstance.fitBounds(bounds.pad(0.1));
            }
            
            // Hide map loading state
            const mapLoading = document.getElementById('mapLoading');
            if (mapLoading) {
                mapLoading.classList.add('hidden');
            }
            
            // Update distance display after map is initialized
            setTimeout(() => {
                updateDistanceDisplay();
            }, 500);
        }
        
        // Handle restaurant card click - scroll to map and highlight location
        function handleRestaurantCardClick(event, restaurantId, lat, lng) {
            // Check if Ctrl/Cmd key is pressed - if so, just navigate normally
            if (event.ctrlKey || event.metaKey) {
                return true; // Allow default navigation
            }
            
            // Prevent default navigation
            event.preventDefault();
            
            // Scroll to map section
            const mapSection = document.getElementById('map');
            if (mapSection) {
                const offsetTop = mapSection.offsetTop - 60;
                window.scrollTo({
                    top: offsetTop,
                    behavior: 'smooth'
                });
            }
            
            // Wait for scroll, then highlight location on map
            setTimeout(() => {
                if (window.mapInstance) {
                    // Center map on location
                    window.mapInstance.setView([lat, lng], 13);
                    
                    // Find and highlight the marker
                    const markerKey = `restaurant-${restaurantId}`;
                    const marker = markerMap.get(markerKey);
                    
                    if (marker) {
                        // Open popup
                        marker.openPopup();
                        
                        // Add a bounce animation
                        marker.setIcon(
                            L.divIcon({
                                className: 'restaurant-marker-highlighted',
                                html: `<div style="width: 32px; height: 32px; background: #10b981; border: 4px solid #0071e3; border-radius: 50%; box-shadow: 0 4px 12px rgba(0,113,227,0.5); animation: pulse 1s ease-in-out;"></div>`,
                                iconSize: [32, 32],
                                iconAnchor: [16, 16]
                            })
                        );
                        
                        // Reset icon after animation
                        setTimeout(() => {
                            const colors = {
                                restaurant: '#10b981',
                                bar: '#3b82f6',
                                cafe: '#f59e0b'
                            };
                            // Find restaurant category from data
                            const restaurant = skiEatsData.restaurants.find(r => r.id === restaurantId);
                            const color = colors[restaurant?.category] || '#6b7280';
                            
                            marker.setIcon(
                                L.divIcon({
                                    className: 'restaurant-marker',
                                    html: `<div style="width: 24px; height: 24px; background: ${color}; border: 2px solid white; border-radius: 50%; box-shadow: 0 2px 6px rgba(0,0,0,0.3);"></div>`,
                                    iconSize: [24, 24],
                                    iconAnchor: [12, 12]
                                })
                            );
                        }, 2000);
                    }
                }
            }, 500);
        }
        
        // Handle resort card click - scroll to map and highlight location
        function handleResortCardClick(event, resortId, lat, lng) {
            // Check if Ctrl/Cmd key is pressed - if so, just navigate normally
            if (event.ctrlKey || event.metaKey) {
                return true; // Allow default navigation
            }
            
            // Prevent default navigation
            event.preventDefault();
            
            // Scroll to map section
            const mapSection = document.getElementById('map');
            if (mapSection) {
                const offsetTop = mapSection.offsetTop - 60;
                window.scrollTo({
                    top: offsetTop,
                    behavior: 'smooth'
                });
            }
            
            // Wait for scroll, then highlight location on map
            setTimeout(() => {
                if (window.mapInstance) {
                    // Center map on location
                    window.mapInstance.setView([lat, lng], 12);
                    
                    // Find and highlight the marker
                    const markerKey = `resort-${resortId}`;
                    const marker = markerMap.get(markerKey);
                    
                    if (marker) {
                        // Open popup
                        marker.openPopup();
                        
                        // Add a bounce animation
                        marker.setIcon(
                            L.divIcon({
                                className: 'resort-marker-highlighted',
                                html: '<div style="width: 40px; height: 40px; background: #0071e3; border: 4px solid #10b981; border-radius: 50%; box-shadow: 0 4px 12px rgba(16,185,129,0.5); animation: pulse 1s ease-in-out;"></div>',
                                iconSize: [40, 40],
                                iconAnchor: [20, 20]
                            })
                        );
                        
                        // Reset icon after animation
                        setTimeout(() => {
                            marker.setIcon(
                                L.divIcon({
                                    className: 'resort-marker',
                                    html: '<div style="width: 32px; height: 32px; background: #0071e3; border: 3px solid white; border-radius: 50%; box-shadow: 0 2px 8px rgba(0,0,0,0.3); display: flex; align-items: center; justify-content: center;"><svg width="16" height="16" fill="white" viewBox="0 0 24 24"><path d="M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5"/></svg></div>',
                                    iconSize: [32, 32],
                                    iconAnchor: [16, 16]
                                })
                            );
                        }, 2000);
                    }
                }
            }, 500);
        }
        
        // Filter Map Markers
        function filterMapMarkers(filter) {
            currentFilter = filter;
            
            if (filter === 'all') {
                // Show all markers
                resortMarkers.forEach(marker => mapInstance.addLayer(marker));
                restaurantMarkers.forEach(marker => mapInstance.addLayer(marker));
            } else if (filter === 'resorts') {
                // Show only resorts
                resortMarkers.forEach(marker => mapInstance.addLayer(marker));
                restaurantMarkers.forEach(marker => mapInstance.removeLayer(marker));
            } else if (filter === 'restaurants') {
                // Show only restaurants
                resortMarkers.forEach(marker => mapInstance.removeLayer(marker));
                restaurantMarkers.forEach(marker => mapInstance.addLayer(marker));
            }
            
            // Update button states
            document.querySelectorAll('.map-filter-btn').forEach(btn => {
                const btnFilter = btn.dataset.filter;
                if (btnFilter === filter) {
                    btn.classList.add('active', 'bg-[var(--accent-blue)]', 'text-white');
                    btn.classList.remove('bg-white', 'text-gray-700', 'border', 'border-gray-300');
                } else {
                    btn.classList.remove('active', 'bg-[var(--accent-blue)]', 'text-white');
                    btn.classList.add('bg-white', 'text-gray-700', 'border', 'border-gray-300');
                }
            });
            
            // Fit map to visible markers and update maxBounds
            const visibleMarkers = filter === 'all' ? markers : 
                                  filter === 'resorts' ? resortMarkers : 
                                  restaurantMarkers;
            
            if (visibleMarkers.length > 0) {
                const group = new L.featureGroup(visibleMarkers);
                const bounds = group.getBounds();
                
                // Update maxBounds to only allow zooming within visible markers (with small padding)
                const paddedBounds = bounds.pad(0.1);
                mapInstance.setMaxBounds(paddedBounds);
                
                // Fit map to show visible markers
                mapInstance.fitBounds(bounds.pad(0.1));
            }
            
            // Update distance display when filter changes
            updateDistanceDisplay();
        }
        
        // Show eat and drink based on user location
        function showNearbyPlaces(userLat, userLng) {
            // Calculate distances and sort
            const placesWithDistance = [...mapData.resorts, ...mapData.restaurants].map(place => {
                const distance = calculateDistance(userLat, userLng, place.lat, place.lng);
                return { ...place, distance };
            }).sort((a, b) => a.distance - b.distance);
            
            // Show top 5 nearest
            const nearest = placesWithDistance.slice(0, 5);
            
            // Create bounds including user location and nearest places
            const allPoints = [[userLat, userLng], ...nearest.map(p => [p.lat, p.lng])];
            const bounds = L.latLngBounds(allPoints);
            
            // Temporarily expand maxBounds to include user location if needed
            const currentMaxBounds = mapInstance.getMaxBounds();
            if (currentMaxBounds && !currentMaxBounds.contains([userLat, userLng])) {
                // Expand maxBounds to include user location
                const expandedBounds = currentMaxBounds.extend([userLat, userLng]);
                mapInstance.setMaxBounds(expandedBounds.pad(0.05));
            }
            
            // Fit map to show user location and nearest places
            mapInstance.fitBounds(bounds, { padding: [50, 50] });
        }
        
        // Calculate distance between two coordinates (Haversine formula)
        function calculateDistance(lat1, lon1, lat2, lon2) {
            const R = 6371; // Radius of the Earth in km
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a = 
                Math.sin(dLat/2) * Math.sin(dLat/2) +
                Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                Math.sin(dLon/2) * Math.sin(dLon/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c; // Distance in km
        }
        
        // Calculate distance in miles
        function calculateDistanceMiles(lat1, lon1, lat2, lon2) {
            return calculateDistance(lat1, lon1, lat2, lon2) * 0.621371;
        }
        
        // Transform restaurant data: convert old resort (string) to new resorts (array) structure
        function normalizeRestaurantResorts(restaurants, resorts) {
            const MAX_DISTANCE_MILES = 30;
            
            return restaurants.map(restaurant => {
                // If already in new format (has resorts array), use it
                if (restaurant.resorts && Array.isArray(restaurant.resorts)) {
                    const sortedResorts = [...restaurant.resorts].sort((a, b) => {
                        if (a.distance === null || a.distance === undefined) return 1;
                        if (b.distance === null || b.distance === undefined) return -1;
                        return a.distance - b.distance;
                    });
                    return { ...restaurant, resorts: sortedResorts };
                }
                
                // Old format: has single resort property - transform it
                if (restaurant.resort) {
                    if (restaurant.coordinates && restaurant.coordinates.lat && restaurant.coordinates.lng) {
                        const restaurantLat = restaurant.coordinates.lat;
                        const restaurantLng = restaurant.coordinates.lng;
                        const nearbyResorts = [];
                        
                        resorts.forEach(resort => {
                            if (resort.coordinates && resort.coordinates.lat && resort.coordinates.lng) {
                                const distance = calculateDistanceMiles(
                                    restaurantLat,
                                    restaurantLng,
                                    resort.coordinates.lat,
                                    resort.coordinates.lng
                                );
                                
                                if (distance <= MAX_DISTANCE_MILES) {
                                    nearbyResorts.push({
                                        id: resort.id,
                                        distance: Math.round(distance * 10) / 10
                                    });
                                }
                            }
                        });
                        
                        nearbyResorts.sort((a, b) => {
                            if (a.distance === null) return 1;
                            if (b.distance === null) return -1;
                            return a.distance - b.distance;
                        });
                        
                        const hasOriginalResort = nearbyResorts.some(r => r.id === restaurant.resort);
                        if (!hasOriginalResort) {
                            const originalResort = resorts.find(r => r.id === restaurant.resort);
                            if (originalResort && originalResort.coordinates) {
                                const distance = calculateDistanceMiles(
                                    restaurantLat,
                                    restaurantLng,
                                    originalResort.coordinates.lat,
                                    originalResort.coordinates.lng
                                );
                                nearbyResorts.push({
                                    id: restaurant.resort,
                                    distance: Math.round(distance * 10) / 10
                                });
                                nearbyResorts.sort((a, b) => a.distance - b.distance);
                            } else {
                                nearbyResorts.unshift({ id: restaurant.resort, distance: null });
                            }
                        }
                        
                        const newRestaurant = { ...restaurant };
                        delete newRestaurant.resort;
                        newRestaurant.resorts = nearbyResorts.length > 0 ? nearbyResorts : [{ id: restaurant.resort, distance: null }];
                        return newRestaurant;
                    } else {
                        const newRestaurant = { ...restaurant };
                        delete newRestaurant.resort;
                        newRestaurant.resorts = [{ id: restaurant.resort, distance: null }];
                        return newRestaurant;
                    }
                }
                
                return { ...restaurant, resorts: [] };
            });
        }
        
        // Get the closest resort for a restaurant
        function getClosestResort(restaurant) {
            if (!restaurant.resorts || restaurant.resorts.length === 0) {
                return null;
            }
            const sorted = [...restaurant.resorts].sort((a, b) => {
                if (a.distance === null || a.distance === undefined) return 1;
                if (b.distance === null || b.distance === undefined) return -1;
                return a.distance - b.distance;
            });
            return sorted[0];
        }
        
        // Get all resorts for a restaurant, sorted by distance
        function getRestaurantResorts(restaurant) {
            if (!restaurant.resorts || restaurant.resorts.length === 0) {
                return [];
            }
            return [...restaurant.resorts].sort((a, b) => {
                if (a.distance === null || a.distance === undefined) return 1;
                if (b.distance === null || b.distance === undefined) return -1;
                return a.distance - b.distance;
            });
        }
        
        // Get resort name(s) for display, showing closest first
        function getResortNamesForDisplay(restaurant, resortsData, maxResorts = 2) {
            const restaurantResorts = getRestaurantResorts(restaurant);
            if (restaurantResorts.length === 0) return '';
            
            const resortNames = restaurantResorts
                .slice(0, maxResorts)
                .map(r => {
                    const resort = resortsData.find(res => res.id === r.id);
                    return resort ? resort.name : r.id;
                });
            
            if (restaurantResorts.length > maxResorts) {
                return resortNames.join(', ') + ` +${restaurantResorts.length - maxResorts} more`;
            }
            return resortNames.join(', ');
        }
        
        // Find nearest resort to a given location
        function findNearestResort(lat, lng) {
            if (!mapData || !mapData.resorts || mapData.resorts.length === 0) {
                return null;
            }
            
            let nearestResort = null;
            let minDistance = Infinity;
            
            mapData.resorts.forEach(resort => {
                const distance = calculateDistance(lat, lng, resort.lat, resort.lng);
                if (distance < minDistance) {
                    minDistance = distance;
                    nearestResort = { ...resort, distance };
                }
            });
            
            return nearestResort;
        }
        
        // Update distance display
        function updateDistanceDisplay() {
            const distanceList = document.getElementById('distanceList');
            if (!distanceList) return;
            
            // Get all visible places based on current filter
            let placesToShow = [];
            
            if (currentFilter === 'all' || currentFilter === 'restaurants') {
                // Add restaurants
                if (mapData && mapData.restaurants) {
                    placesToShow.push(...mapData.restaurants.map(r => ({
                        name: r.name,
                        location: r.location,
                        lat: r.lat,
                        lng: r.lng,
                        type: 'restaurant',
                        category: r.category || 'restaurant'
                    })));
                }
            }
            
            // Add other places if they're active
            Object.keys(otherPlacesMarkers).forEach(type => {
                if (activeOtherPlacesTypes.has(type)) {
                    otherPlacesMarkers[type].forEach(marker => {
                        const latlng = marker.getLatLng();
                        const popup = marker.getPopup();
                        const popupContent = popup ? popup.getContent() : '';
                        // Extract name from popup content
                        const nameMatch = popupContent.match(/<h3>(.*?)<\/h3>/);
                        const name = nameMatch ? nameMatch[1] : otherPlacesTypeMapping[type]?.name || 'Unknown';
                        
                        placesToShow.push({
                            name: name,
                            location: '',
                            lat: latlng.lat,
                            lng: latlng.lng,
                            type: 'other',
                            category: type
                        });
                    });
                }
            });
            
            if (placesToShow.length === 0) {
                distanceList.innerHTML = `
                    <div class="text-center py-8 text-gray-500">
                        <svg class="w-12 h-12 mx-auto mb-3 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 20l-5.447-2.724A1 1 0 013 16.382V5.618a1 1 0 011.447-.894L9 7m0 13l6-3m-6 3V7m6 10l4.553 2.276A1 1 0 0021 18.382V7.618a1 1 0 00-.553-.894L15 4m0 13V4m0 0L9 7"></path>
                        </svg>
                        <p>No places to display. Try adjusting your filters.</p>
                    </div>
                `;
                return;
            }
            
            // Calculate distances for each place
            const placesWithDistances = placesToShow.map(place => {
                const nearest = findNearestResort(place.lat, place.lng);
                return {
                    ...place,
                    nearestResort: nearest ? nearest.name : 'Unknown',
                    distance: nearest ? nearest.distance : null
                };
            }).sort((a, b) => {
                if (a.distance === null) return 1;
                if (b.distance === null) return -1;
                return a.distance - b.distance;
            });
            
            // Render the list
            distanceList.innerHTML = placesWithDistances.map(place => {
                const distanceMiles = place.distance ? (place.distance * 0.621371).toFixed(1) : 'N/A';
                const distanceKm = place.distance ? place.distance.toFixed(1) : 'N/A';
                const categoryColors = {
                    restaurant: '#10b981',
                    bar: '#3b82f6',
                    cafe: '#f59e0b',
                    fuel: '#f59e0b',
                    hotel: '#8b5cf6',
                    parking: '#6366f1',
                    atm: '#ec4899',
                    pharmacy: '#ef4444'
                };
                const categoryLabels = {
                    restaurant: 'Restaurant',
                    bar: 'Bar',
                    cafe: 'Café',
                    fuel: 'Gas Station',
                    hotel: 'Hotel',
                    parking: 'Parking',
                    atm: 'ATM',
                    pharmacy: 'Pharmacy'
                };
                const primaryCategory = getPrimaryCategory(place, 'restaurant');
                const color = categoryColors[primaryCategory] || '#6b7280';
                const label = categoryLabels[primaryCategory] || 'Place';
                
                return `
                    <div class="flex items-center justify-between p-4 bg-gray-50 rounded-lg hover:bg-gray-100 transition-colors duration-200">
                        <div class="flex-1">
                            <div class="flex items-center gap-3">
                                <div class="flex-shrink-0 w-3 h-3 rounded-full" style="background-color: ${color};"></div>
                                <div class="flex-1 min-w-0">
                                    <h4 class="font-semibold text-gray-900 truncate">${place.name}</h4>
                                    <div class="flex items-center gap-2 mt-1">
                                        <span class="text-xs px-2 py-0.5 rounded-full text-white" style="background-color: ${color};">${label}</span>
                                        ${place.location ? `<span class="text-xs text-gray-600 truncate">${place.location}</span>` : ''}
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="flex-shrink-0 text-right ml-4">
                            <div class="text-sm font-semibold text-gray-900">${distanceMiles} mi</div>
                            <div class="text-xs text-gray-500">${distanceKm} km</div>
                            <div class="text-xs text-gray-600 mt-1">to ${place.nearestResort}</div>
                        </div>
                    </div>
                `;
            }).join('');
        }
        
        // Map Control Buttons
        const showAllBtn = document.getElementById('showAllBtn');
        const findMyLocationBtn = document.getElementById('findMyLocationBtn');
        const filterMapBtn = document.getElementById('filterMapBtn');
        
        // Map Filter Buttons
        const showAllMapBtn = document.getElementById('showAllMapBtn');
        const showResortsMapBtn = document.getElementById('showResortsMapBtn');
        const showRestaurantsMapBtn = document.getElementById('showRestaurantsMapBtn');
        
        if (showAllMapBtn) {
            showAllMapBtn.addEventListener('click', () => filterMapMarkers('all'));
        }
        
        if (showResortsMapBtn) {
            showResortsMapBtn.addEventListener('click', () => filterMapMarkers('resorts'));
        }
        
        if (showRestaurantsMapBtn) {
            showRestaurantsMapBtn.addEventListener('click', () => filterMapMarkers('restaurants'));
        }
        
        // Other Places Functionality
        const otherPlacesTypeMapping = {
            'fuel': { name: 'Gas Stations', icon: '⛽', color: '#f59e0b' },
            'hotel': { name: 'Hotels', icon: '🏨', color: '#8b5cf6' },
            'parking': { name: 'Parking', icon: '🅿️', color: '#6366f1' },
            'atm': { name: 'ATMs', icon: '💳', color: '#ec4899' },
            'pharmacy': { name: 'Pharmacies', icon: '💊', color: '#ef4444' }
        };
        
        // Fetch places from Overpass API (OpenStreetMap)
        async function fetchOtherPlaces(type, bounds) {
            if (!window.mapInstance || !bounds) return [];
            
            const overpassUrl = 'https://overpass-api.de/api/interpreter';
            
            // Map our types to OSM tags
            const osmTagMapping = {
                'fuel': 'amenity=fuel',
                'hotel': 'tourism=hotel',
                'parking': 'amenity=parking',
                'atm': 'amenity=atm',
                'pharmacy': 'amenity=pharmacy'
            };
            
            const tag = osmTagMapping[type];
            if (!tag) return [];
            
            const [south, west, north, east] = [
                bounds.getSouth(),
                bounds.getWest(),
                bounds.getNorth(),
                bounds.getEast()
            ];
            
            const query = `
                [out:json][timeout:25];
                (
                    node[${tag}](${south},${west},${north},${east});
                    way[${tag}](${south},${west},${north},${east});
                    relation[${tag}](${south},${west},${north},${east});
                );
                out center meta;
            `;
            
            try {
                const response = await fetch(overpassUrl, {
                    method: 'POST',
                    body: query
                });
                
                if (!response.ok) {
                    throw new Error('Failed to fetch places');
                }
                
                const data = await response.json();
                return data.elements || [];
            } catch (error) {
                console.error(`Error fetching ${type}:`, error);
                return [];
            }
        }
        
        // Add other places markers to map
        async function toggleOtherPlaces(type) {
            if (!window.mapInstance) return;
            
            const isActive = activeOtherPlacesTypes.has(type);
            const placeInfo = otherPlacesTypeMapping[type];
            
            if (isActive) {
                // Remove markers
                otherPlacesMarkers[type].forEach(marker => {
                    window.mapInstance.removeLayer(marker);
                });
                otherPlacesMarkers[type] = [];
                activeOtherPlacesTypes.delete(type);
                
                // Update button
                const btn = document.querySelector(`[data-type="${type}"]`);
                if (btn) {
                    btn.classList.remove('active');
                }
                
                // Update distance display
                updateDistanceDisplay();
            } else {
                // Fetch and add markers
                const bounds = window.mapInstance.getBounds();
                const places = await fetchOtherPlaces(type, bounds);
                
                const icon = L.divIcon({
                    className: `other-place-marker-${type}`,
                    html: `<div style="width: 20px; height: 20px; background: ${placeInfo.color}; border: 2px solid white; border-radius: 50%; box-shadow: 0 2px 6px rgba(0,0,0,0.3); display: flex; align-items: center; justify-content: center; font-size: 10px;">${placeInfo.icon}</div>`,
                    iconSize: [20, 20],
                    iconAnchor: [10, 10]
                });
                
                places.forEach(place => {
                    const lat = place.lat || (place.center && place.center.lat);
                    const lng = place.lon || (place.center && place.center.lon);
                    
                    if (lat && lng) {
                        const name = place.tags?.name || placeInfo.name;
                        const address = place.tags?.['addr:full'] || place.tags?.['addr:street'] || '';
                        
                        // Create directions URLs
                        const googleMapsUrl = `https://www.google.com/maps/dir/?api=1&destination=${lat},${lng}`;
                        const appleMapsUrl = `https://maps.apple.com/?daddr=${lat},${lng}`;
                        const wazeUrl = `https://waze.com/ul?ll=${lat},${lng}&navigate=yes`;
                        
                        const marker = L.marker([lat, lng], { icon: icon })
                            .addTo(window.mapInstance)
                            .bindPopup(`
                                <div class="map-marker-popup">
                                    <h3>${name}</h3>
                                    ${address ? `<p style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">${address}</p>` : ''}
                                    <p style="color: ${placeInfo.color}; font-weight: 500; margin-bottom: 12px; font-size: 12px;">
                                        ${placeInfo.name}
                                    </p>
                                    <a href="${googleMapsUrl}" target="_blank" rel="noopener noreferrer" style="display: inline-block; padding: 6px 12px; background: #10b981; color: white; border-radius: 16px; text-decoration: none; font-size: 12px; font-weight: 500; transition: opacity 0.2s;" onmouseover="this.style.opacity='0.9'" onmouseout="this.style.opacity='1'">
                                        🗺️ Directions
                                    </a>
                                    <div style="display: flex; gap: 4px; flex-wrap: wrap; margin-top: 6px;">
                                        <a href="${googleMapsUrl}" target="_blank" rel="noopener noreferrer" style="font-size: 10px; color: #6b7280; text-decoration: none; padding: 3px 6px; border: 1px solid #e5e7eb; border-radius: 10px;">Google</a>
                                        <a href="${appleMapsUrl}" target="_blank" rel="noopener noreferrer" style="font-size: 10px; color: #6b7280; text-decoration: none; padding: 3px 6px; border: 1px solid #e5e7eb; border-radius: 10px;">Apple</a>
                                        <a href="${wazeUrl}" target="_blank" rel="noopener noreferrer" style="font-size: 10px; color: #6b7280; text-decoration: none; padding: 3px 6px; border: 1px solid #e5e7eb; border-radius: 10px;">Waze</a>
                                    </div>
                                </div>
                            `);
                        
                        otherPlacesMarkers[type].push(marker);
                    }
                });
                
                activeOtherPlacesTypes.add(type);
                
                // Update button
                const btn = document.querySelector(`[data-type="${type}"]`);
                if (btn) {
                    btn.classList.add('active');
                }
                
                // Update distance display
                updateDistanceDisplay();
            }
        }
        
        // Event listeners for other places buttons
        function setupOtherPlacesButtons() {
            document.querySelectorAll('.other-places-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const type = btn.getAttribute('data-type');
                    if (type && window.mapInstance) {
                        toggleOtherPlaces(type);
                    }
                });
            });
        }
        
        // Setup buttons when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', setupOtherPlacesButtons);
        } else {
            setupOtherPlacesButtons();
        }
        
        // Update other places when map moves (optional - for dynamic loading)
        let otherPlacesUpdateTimeout = null;
        function setupMapMoveListener() {
            if (window.mapInstance) {
                window.mapInstance.on('moveend', () => {
                    // Debounce updates
                    clearTimeout(otherPlacesUpdateTimeout);
                    otherPlacesUpdateTimeout = setTimeout(() => {
                        // Optionally reload places when map moves significantly
                        // This can be enabled if you want dynamic loading
                    }, 1000);
                });
            }
        }
        
        // Setup map move listener after map is initialized
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                setTimeout(setupMapMoveListener, 500);
            });
        } else {
            setTimeout(setupMapMoveListener, 500);
        }
        
        // State Selection Mode Functionality
        const selectStateBtn = document.getElementById('selectStateBtn');
        const selectStateBtnText = document.getElementById('selectStateBtnText');
        let stateSelectionMode = false;
        let stateLayers = [];
        let stateLayerGroup = null;
        
        // State boundaries (approximate center and bounds for zooming)
        const stateBounds = {
            'Colorado': { center: [39.0, -105.5], bounds: [[36.9, -109.0], [41.0, -102.0]] },
            'Utah': { center: [39.5, -111.5], bounds: [[37.0, -114.0], [42.0, -109.0]] },
            'California': { center: [37.0, -120.0], bounds: [[32.5, -124.5], [42.0, -114.0]] },
            'Wyoming': { center: [43.0, -107.5], bounds: [[41.0, -111.0], [45.0, -104.0]] },
            'Vermont': { center: [44.0, -72.7], bounds: [[42.7, -73.4], [45.0, -71.5]] },
            'New Hampshire': { center: [43.7, -71.6], bounds: [[42.7, -72.6], [45.3, -70.6]] },
            'Maine': { center: [44.3, -69.8], bounds: [[43.0, -71.1], [47.5, -66.9]] },
            'New York': { center: [42.7, -74.8], bounds: [[40.5, -79.8], [45.0, -71.8]] },
            'Pennsylvania': { center: [40.5, -77.2], bounds: [[39.7, -80.5], [42.3, -74.7]] },
            'Idaho': { center: [44.2, -114.5], bounds: [[42.0, -117.0], [49.0, -111.0]] },
            'Montana': { center: [47.0, -110.5], bounds: [[45.0, -116.0], [49.0, -104.0]] },
            'New Mexico': { center: [34.5, -106.0], bounds: [[31.3, -109.0], [37.0, -103.0]] },
            'Nevada': { center: [39.0, -117.0], bounds: [[35.0, -120.0], [42.0, -114.0]] },
            'Oregon': { center: [44.0, -120.5], bounds: [[42.0, -124.5], [46.3, -116.5]] },
            'Washington': { center: [47.4, -120.5], bounds: [[45.5, -124.8], [49.0, -116.9]] },
            'British Columbia': { center: [53.7, -125.0], bounds: [[48.2, -139.0], [60.0, -114.0]] },
            'Alberta': { center: [53.9, -116.6], bounds: [[49.0, -120.0], [60.0, -110.0]] },
            'Quebec': { center: [46.8, -71.2], bounds: [[45.0, -79.8], [50.0, -57.0]] },
            'Ontario': { center: [50.0, -85.0], bounds: [[41.7, -95.2], [56.9, -74.4]] }
        };
        
        function createStateLayers() {
            if (!mapInstance) return;
            
            // Remove existing layers if any
            if (stateLayerGroup) {
                mapInstance.removeLayer(stateLayerGroup);
            }
            
            stateLayers = [];
            stateLayerGroup = L.layerGroup();
            
            // Create rectangular polygons for each state
            Object.keys(stateBounds).forEach(stateName => {
                const bounds = stateBounds[stateName].bounds;
                const rectangle = L.rectangle(bounds, {
                    color: 'transparent',
                    fillColor: 'transparent',
                    fillOpacity: 0,
                    weight: 0,
                    interactive: true,
                    className: 'state-boundary'
                });
                
                // Add hover and click handlers
                rectangle.on('mouseover', function() {
                    this.setStyle({
                        fillColor: '#0071e3',
                        fillOpacity: 0.2,
                        color: '#0071e3',
                        weight: 2
                    });
                });
                
                rectangle.on('mouseout', function() {
                    this.setStyle({
                        fillColor: 'transparent',
                        fillOpacity: 0,
                        color: 'transparent',
                        weight: 0
                    });
                });
                
                rectangle.on('click', function() {
                    filterByState(stateName);
                    deactivateStateSelectionMode();
                });
                
                // Store state name in layer
                rectangle.stateName = stateName;
                
                stateLayers.push(rectangle);
                stateLayerGroup.addLayer(rectangle);
            });
            
            stateLayerGroup.addTo(mapInstance);
        }
        
        function removeStateLayers() {
            if (stateLayerGroup && mapInstance) {
                mapInstance.removeLayer(stateLayerGroup);
                stateLayerGroup = null;
                stateLayers = [];
            }
        }
        
        function activateStateSelectionMode() {
            stateSelectionMode = true;
            if (selectStateBtn) {
                selectStateBtn.classList.add('bg-[var(--accent-blue)]', 'text-white');
                selectStateBtn.classList.remove('bg-white', 'text-gray-700');
            }
            if (selectStateBtnText) {
                selectStateBtnText.textContent = 'Click a State on the Map';
            }
            createStateLayers();
        }
        
        function deactivateStateSelectionMode() {
            stateSelectionMode = false;
            if (selectStateBtn) {
                selectStateBtn.classList.remove('bg-[var(--accent-blue)]', 'text-white');
                selectStateBtn.classList.add('bg-white', 'text-gray-700');
            }
            if (selectStateBtnText) {
                selectStateBtnText.textContent = 'Select State/Province';
            }
            removeStateLayers();
        }
        
        function filterByState(state) {
            if (!mapInstance) return;
            
            if (state === 'all') {
                // Show all markers based on current filter
                filterMapMarkers(currentFilter);
                return;
            }
            
            // Hide all markers first
            resortMarkers.forEach(marker => mapInstance.removeLayer(marker));
            restaurantMarkers.forEach(marker => mapInstance.removeLayer(marker));
            
            // Find markers in selected state by matching location strings
            const visibleResortMarkers = [];
            const visibleRestaurantMarkers = [];
            
            mapData.resorts.forEach((resort, index) => {
                const location = resort.location || '';
                if (location.includes(state)) {
                    if (resortMarkers[index]) {
                        visibleResortMarkers.push(resortMarkers[index]);
                    }
                }
            });
            
            mapData.restaurants.forEach((restaurant, index) => {
                const location = restaurant.location || '';
                if (location.includes(state)) {
                    if (restaurantMarkers[index]) {
                        visibleRestaurantMarkers.push(restaurantMarkers[index]);
                    }
                }
            });
            
            // Apply current filter (all, resorts, or restaurants)
            if (currentFilter === 'all') {
                visibleResortMarkers.forEach(marker => mapInstance.addLayer(marker));
                visibleRestaurantMarkers.forEach(marker => mapInstance.addLayer(marker));
            } else if (currentFilter === 'resorts') {
                visibleResortMarkers.forEach(marker => mapInstance.addLayer(marker));
            } else if (currentFilter === 'restaurants') {
                visibleRestaurantMarkers.forEach(marker => mapInstance.addLayer(marker));
            }
            
            // Zoom to state bounds
            if (stateBounds[state]) {
                const bounds = stateBounds[state].bounds;
                const latLngBounds = L.latLngBounds(bounds);
                
                // Get visible markers for bounds
                const visibleMarkers = currentFilter === 'all' 
                    ? [...visibleResortMarkers, ...visibleRestaurantMarkers]
                    : currentFilter === 'resorts' 
                    ? visibleResortMarkers 
                    : visibleRestaurantMarkers;
                
                if (visibleMarkers.length > 0) {
                    const markerGroup = new L.featureGroup(visibleMarkers);
                    const markerBounds = markerGroup.getBounds();
                    mapInstance.fitBounds(markerBounds.pad(0.1));
                    
                    // Set maxBounds to state area
                    mapInstance.setMaxBounds(latLngBounds.pad(0.1));
                } else {
                    // If no markers, just zoom to state center
                    mapInstance.setView(stateBounds[state].center, 7);
                    mapInstance.setMaxBounds(latLngBounds.pad(0.1));
                }
            }
        }
        
        if (selectStateBtn) {
            selectStateBtn.addEventListener('click', () => {
                if (stateSelectionMode) {
                    deactivateStateSelectionMode();
                } else {
                    activateStateSelectionMode();
                }
            });
        }
        
        if (showAllBtn) {
            showAllBtn.addEventListener('click', () => {
                if (mapInstance) {
                    // Fit map to show all visible markers based on current filter
                    const visibleMarkers = currentFilter === 'all' ? markers : 
                                          currentFilter === 'resorts' ? resortMarkers : 
                                          restaurantMarkers;
                    if (visibleMarkers.length > 0) {
                        const group = new L.featureGroup(visibleMarkers);
                        const bounds = group.getBounds();
                        
                        // Update maxBounds to match visible markers
                        const paddedBounds = bounds.pad(0.1);
                        mapInstance.setMaxBounds(paddedBounds);
                        
                        // Fit map to visible markers
                        mapInstance.fitBounds(bounds.pad(0.1));
                    }
                }
            });
        }
        
        if (findMyLocationBtn) {
            findMyLocationBtn.addEventListener('click', () => {
                if (navigator.geolocation) {
                    navigator.geolocation.getCurrentPosition(
                        (position) => {
                            const { latitude, longitude } = position.coords;
                            if (mapInstance) {
                                mapInstance.setView([latitude, longitude], 10);
                                
                                // Add/update user location marker
                                if (userLocationMarker) {
                                    mapInstance.removeLayer(userLocationMarker);
                                }
                                userLocationMarker = L.marker([latitude, longitude], {
                                    icon: L.divIcon({
                                        className: 'user-location-marker',
                                        html: '<div style="width: 20px; height: 20px; background: #0071e3; border: 3px solid white; border-radius: 50%; box-shadow: 0 2px 8px rgba(0,0,0,0.3);"></div>',
                                        iconSize: [20, 20],
                                        iconAnchor: [10, 10]
                                    })
                                }).addTo(mapInstance)
                                .bindPopup('<strong>Your Location</strong>').openPopup();
                                
                                window.userLocationMarker = userLocationMarker;
                                
                                showNearbyPlaces(latitude, longitude);
                            }
                        },
                        (error) => {
                            alert('Unable to get your location. Please check your browser settings.');
                        }
                    );
                } else {
                    alert('Geolocation is not supported by your browser.');
                }
            });
        }
        
        
        // Initialize map when page loads
        if (document.readyState === 'loading') {
            // Loading overlay management
            function showLoading() {
                const overlay = document.getElementById('loadingOverlay');
                if (overlay) overlay.classList.add('active');
            }
            
            function hideLoading() {
                const overlay = document.getElementById('loadingOverlay');
                if (overlay) overlay.classList.remove('active');
            }
            
            document.addEventListener('DOMContentLoaded', () => {
                showLoading();
                
                // Hide loading after initial render
                setTimeout(() => {
                    hideLoading();
                }, 800);
            });
        }
        
        // Listen for home base changes and refresh content
        window.addEventListener('homebaseChanged', () => {
            // Refresh restaurant and resort cards when home base changes
            if (typeof renderRestaurantCards === 'function') {
                renderRestaurantCards();
            }
            if (typeof renderResortCards === 'function') {
                renderResortCards();
            }
            
            // Update section titles
            updateSectionTitles();
        });
        
        // Function to update section titles based on home base
        function updateSectionTitles() {
            const homeBaseActive = typeof HomeBase !== 'undefined' && HomeBase.isActive();
            const homeBaseName = homeBaseActive ? HomeBase.getResortName() : null;
            
            // Update resort section titles
            const featuredResortTitle = document.getElementById('featuredResortTitle');
            const closestResortTitle = document.getElementById('closestResortTitle');
            
            if (homeBaseActive && homeBaseName) {
                if (featuredResortTitle) {
                    featuredResortTitle.textContent = 'Home Base';
                }
                if (closestResortTitle) {
                    closestResortTitle.textContent = `Resorts Near ${homeBaseName}`;
                }
            } else {
                if (featuredResortTitle) {
                    featuredResortTitle.textContent = 'Featured Resort';
                }
                if (closestResortTitle) {
                    closestResortTitle.textContent = 'Closest Resort';
                }
            }
            
            // Update restaurant section titles
            const restaurantsSectionTitle = document.getElementById('restaurantsSectionTitle');
            const restaurantsSectionDescription = document.getElementById('restaurantsSectionDescription');
            
            if (homeBaseActive && homeBaseName) {
                if (restaurantsSectionTitle) {
                    restaurantsSectionTitle.textContent = `Closest places to grab a bite near ${homeBaseName}`;
                }
                if (restaurantsSectionDescription) {
                    restaurantsSectionDescription.textContent = `Discover exceptional dining experiences near ${homeBaseName} and surrounding ski resorts.`;
                }
            } else {
                if (restaurantsSectionTitle) {
                    restaurantsSectionTitle.textContent = 'Closest places to grab a bite';
                }
                if (restaurantsSectionDescription) {
                    restaurantsSectionDescription.textContent = 'Discover exceptional dining experiences at ski resorts across North America.';
                }
            }
        }
        
        // Update titles on initial load
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                setTimeout(updateSectionTitles, 100);
            });
        } else {
            setTimeout(updateSectionTitles, 100);
        }
        
        // Adjust nav positioning for home base bar
        function adjustNavForHomeBase() {
            const homebaseBar = document.getElementById('homebase-bar');
            const nav = document.querySelector('nav');
            if (homebaseBar && nav) {
                const barHeight = homebaseBar.offsetHeight;
                if (homebaseBar.style.display !== 'none') {
                    nav.style.top = `${barHeight}px`;
                } else {
                    nav.style.top = '0';
                }
            }
        }
        
        // Watch for home base bar visibility changes
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                setTimeout(() => {
                    adjustNavForHomeBase();
                    const observer = new MutationObserver(adjustNavForHomeBase);
                    const homebaseBar = document.getElementById('homebase-bar');
                    if (homebaseBar) {
                        observer.observe(homebaseBar, { attributes: true, attributeFilter: ['style'] });
                    }
                }, 500);
            });
        } else {
            setTimeout(() => {
                adjustNavForHomeBase();
                const observer = new MutationObserver(adjustNavForHomeBase);
                const homebaseBar = document.getElementById('homebase-bar');
                if (homebaseBar) {
                    observer.observe(homebaseBar, { attributes: true, attributeFilter: ['style'] });
                }
            }, 500);
        }
    </script>
</body>
</html>

<!-- Deployment trigger -->
<!-- Trigger deployment -->
<!-- Auto-deploy test -->
